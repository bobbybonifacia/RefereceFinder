/******************************************************************************	ReferenceFinder - a program for finding compact folding sequences for locating 	approximate reference points on a unit square.		Version 3.1		Copyright ©1999-2003 by Robert J. Lang. All rights reserved.		Rights of usage: you may compile this code and modifications thereof for your 	own personal use. You may not redistribute this code or modifications thereof.		ReferenceFinder is ANSI C++ code that should compile for any compiler/platform	that supports the C++ standard library.		After the program initializes, the user is prompted for x and y coordinates of	a desired point or line. The program responds with several folding sequences based on 	lines and marks made by folding (no measuring).		See file "README.txt" for version history and compilation notes.******************************************************************************/ // #define CALCINPUT to use the expression evaluator, which accepts symbolic input. If// CALCINPUT is undefined, we'll just use the standard console cin, which wants to see// decimal values.#define CALCINPUT 1#include "ReferenceFinder.h"using namespace std;// if we're using CodeWarrior for the Mac, customize the size of the console window.// __MACOS__ is a CodeWarrior predefined compiler symbol. If we're running CodeWarrior,// the we're using SIOUX as our console window, so we can go in and manipulate the // SIOUX globals to expand the console window.	#ifdef __MWERKS__#ifdef __MACOS__#include <SIOUX.h>#endif#endif//#include "profiler.h"	// Uncomment this to generate profiling information/*******	readNumber (double &n) - Get a number from the user, either via the expression*	evaluator (if CALCINPUT is defined) or from the standard input cin.******/#ifdef CALCINPUT#include "parser.h"Parser parser;/* Read a string from console, parse a numerical expression and   save result in parameter. Loop until a valid expression is   entered. Abort if user ends input.   At present, double readNumber (void) would be enough; we could   generalize it to boolean readNumber (double &) and let user   abort without entering a valid expression.*/ static void readNumber (double &n, bool assumeDefault = true) {  string buffer;	// text read here  for ( ; ! cin.eof (); ) {    getline (cin, buffer);    Parser::errType err = parser.evaluate (buffer, n, assumeDefault);    if (err != Parser::none)      cerr << "  Error (" << Parser::parseMessage (err) << "), try again: ";    else      break;  }  if (cin.eof ())    exit (0);}#else// Use the std console if we're not using the expression evaluatorstatic void readNumber (double& n, bool) {	cin >> n;}#endif/********************************	Main program loop*******************************/int main(){	#ifdef __MACOS__#ifdef __MWERKS__	// blow up the SIOUX console window to display more characters and rows.	// SIOUX will shrink the console to fit the screen.	// Also on quit, close the window.		SIOUXSettings.rows = 120;	SIOUXSettings.columns = 120;	SIOUXSettings.autocloseonquit = true;#endif#endif		cout << "ReferenceFinder v. 3.1" << endl;	cout << "Copyright ©1999-2003 by Robert J. Lang. All rights reserved." << endl;		#ifdef __PROFILER__	ProfilerInit(collectDetailed, bestTimeBase, 200, 15);	// Turn on the profiler#endif	ReferenceFinder::MakeAllMarksAndLines();				// Make a complete set of marks#ifdef __PROFILER__	ProfilerDump("\pReferenceFinder 3.1.prof");				// dump profile info to file#endif	//	Loop forever until the user quits from the menu.	while (1) {		cout << "0 = exit, 1 = find mark, 2 = find line : ";		double ns;		readNumber(ns, false);		switch (int(ns)) {			case 0:				{					exit(1);				};				break;						case 1:				{					XYPt pp(0, 0);						cout << endl << "Enter x coordinate: ";					readNumber (pp.x);					cout << "Enter y coordinate: ";					readNumber (pp.y);					if (ReferenceFinder::ValidateMark(pp)) {						vector<RefMark*> vm;						ReferenceFinder::FindBestMarks(pp, vm, 5);												// Write verbal directions to the console						ConsoleTextDgmr tdgmr;						tdgmr.PutMarkList(pp, vm);												// Also draw Postscript directions to a file						PSFileDgmr pdgmr;						pdgmr.PutMarkList(pp, vm);						cout << "Diagrams in <" << pdgmr.fileName << ">." << endl;					}				}				break;					case 2:				{					XYPt p1, p2;					cout << endl << "Enter p1 x coordinate: ";					readNumber (p1.x);					cout << "Enter p1 y coordinate: ";					readNumber (p1.y);					cout << endl << "Enter p2 x coordinate: ";					readNumber (p2.x);					cout << "Enter p2 y coordinate: ";					readNumber (p2.y);					if (ReferenceFinder::ValidateLine(p1, p2)) {						XYLine ll(p1, p2);						vector<RefLine*> vl;						ReferenceFinder::FindBestLines(ll, vl, 5);												// Write verbal directions to the console						ConsoleTextDgmr tdgmr;						tdgmr.PutLineList(ll, vl);												// Also draw Postscript directions to a file						PSFileDgmr pdgmr;						pdgmr.PutLineList(ll, vl);						cout << "Diagrams in <" << pdgmr.fileName << ">." << endl;					}				}				break;									case 99:	// hidden command to calculate statistics on marks				ReferenceFinder::CalcStatistics();				break;						default:				cout << "Enter just 0, 1 or 2, please.\n\n";		}	};	return 0;}