/******************************************************************************	ReferenceFinder - a program for finding compact folding sequences for locating 	approximate reference points on a unit square.		Version 3.1		Copyright ©1999-2003 by Robert J. Lang. All rights reserved.		Rights of usage: you may compile this code and modifications thereof for your 	own personal use. You may not redistribute this code or modifications thereof.		ReferenceFinder is ANSI C++ code that should compile for any compiler/platform	that supports the C++ standard library.		After the program initializes, the user is prompted for x and y coordinates of	a desired point or line. The program responds with several folding sequences based on 	lines and marks made by folding (no measuring).		See file "README.txt" for version history and compilation notes.******************************************************************************/ #include "ReferenceFinder.h"#include <fstream>#include <sstream>#include <limits>#include <algorithm>#include <iomanip>using namespace std;// #define NO_CONSOLE to suppress all console functions (e.g., for a standalone module)// other than in class ConsoleTextDgmr, which is expressly designed for console output./*******	static member initialization -- variables that you might want to change (because they*	alter the behavior of the program) are defined here. Other static member variables are *	defined lower down in their respective sections.******/// Maximum rank and number of marks and lines to collect. These can be tweaked // up or down to trade off accuracy versus memory and initialization time.RefBase::rank_t ReferenceFinder::maxRank = 6;size_t ReferenceFinder::maxLines = 249323;size_t ReferenceFinder::maxMarks = 300000;// constants that quantify the discretization of marks and lines in forming keys.// The maximum key has the value (xNum * yNum) for marks, (aNum * dNum) for lines.// These numbers set a limit on the accuracy, since we won't create more than one// object for a given key.int RefMark::xNum = 2000;int RefMark::yNum = 2000;int RefLine::aNum = 2000;int RefLine::dNum = 2000;	// Defines "good enough" for a mark. For marks with errors better than this, we give// priority to lower-rank marks.double ReferenceFinder::maxError = .005;// Minimum allowable aspect ratio for a flap. Too skinny of a flap can't be folded// accurately.double ReferenceFinder::minAspectRatio = 0.100;// Sine of minimum intersection angle between creases that define a new mark. If// the lines are close to parallel, the mark is imprecise.double ReferenceFinder::minAngleSine = 0.342;	// = sin(20 degrees)// If visibilityMatters == true, we don't construct alignments that can't be made// with opaque paper. Otherwise, we allow alignments that can be done with // translucent paper.bool ReferenceFinder::visibilityMatters = true;// If clarifyVerbalAmbiguities == true, then verbal instructions that could be ambigious// because there are multiples solutions are clarified with additional information.// This is turned on and off by clients using RefBase::SetClarifyVerbalAmbiguities().bool RefBase::clarifyVerbalAmbiguities = true;// If axiomsInVerbalDirections == true, we list the axiom number at the beginning of// each verbal direction. This is turned on/off by clients using // RefBase::SetAxiomsInVerbalDirections().bool RefBase::axiomsInVerbalDirections = true;		// These are switches by which we can turn on and off the use of different types// of alignments. Default is to use all possible.bool RefLine_C2P_C2P::include = true;bool RefLine_P2P::include = true;bool RefLine_L2L::include = true;bool RefLine_L2L_C2P::include = true;bool RefLine_P2L_C2P::include = true;bool RefLine_P2L_P2L::include = true;bool RefLine_L2L_P2L::include = true;// We make a call to our show progress callback routine every maxTries attempts.int ReferenceFinder::maxTries = 200000;// Letters that are used for labels for marks and lines.char RefLine::mLabels[] = "ABCDEFGHIJ";char RefMark::mLabels[] = "PQRSTUVWXYZ";// Use unit square paperPaper RefBase::paper(1.0, 1.0);/********************************************************************************	Section 1: lightweight classes that represent points and lines*******************************************************************************//************	XYPt - a 2-vector that represents a point or 2-vector (direction vector).*	It is a lightweight mathematical object. Most operations are defined in the*	header, intended to be inlined for speed.***********//*******	operator<<(ostream& os, const XYPt& p) - Stream I/O for a XYPt spits out the *	point as a parenthesis-enclosed, comma-delimited pair.******/ostream& operator<<(ostream& os, const XYPt& p){	return os << "(" << (p.x) << "," << (p.y) << ")";}/************	XYLine - a class for representing a line by a scalar d and the unit normal to the*	line, u, where the point d*u is the point on the line closest to the origin. *	Note that (d,u) and (-d,-u) represent the same line. If u isn't a unit vector,*	many things will break, so when in doubt, use Normalize() or NormalizeSelf().***********//*******	operator<<(ostream& os, const XYLine& l) - Stream I/O for a XYLine spits out the *	values of d and u as a parenthesis-enclosed, comma-delimited pair, e.g., "(0,(1,0))".******/ostream& operator<<(ostream& os, const XYLine& l){	return os << "(" << (l.d) << "," << (l.u) << ")";}/************	XYRect - a class for representing rectangles by two points, the bottom left and*	top right corners.***********//*******	XYRect::GetAspectRatio() - return the aspect ratio of the rectangle, defined to be*	the smaller dimension divided by the larger dimension. If it's empty, return zero.*	If the rectangles is improperly defined, the aspect ratio may be negative.******/const double XYRect::GetAspectRatio() const{	double wd = GetWidth();	double ht = GetHeight();	if (abs(wd) < EPS && abs(ht) < EPS) return 0;	if (abs(wd) <= abs(ht)) return wd / ht;	return ht / wd;}/*******	XYRect::Include(const XYPt& p) - expand the XYRect to include the point p.******/XYRect& XYRect::Include(const XYPt& p){	if (bl.x > p.x) bl.x = p.x;	if (bl.y > p.y) bl.y = p.y;	if (tr.x < p.x) tr.x = p.x;	if (tr.y < p.y) tr.y = p.y;	return *this;}/*******	BoundingBox(const XYPt& p1, const XYPt& p2) - return an XYRect that includes both points.******/const XYRect BoundingBox(const XYPt& p1, const XYPt& p2){	XYRect r(p1);	return r.Include(p2);}/*******	BoundingBox(const XYPt& p1, const XYPt& p2, const XYPt& p3) - return an XYRect that*	includes all three points.******/const XYRect BoundingBox(const XYPt& p1, const XYPt& p2, const XYPt& p3){	XYRect r(p1);	return r.Include(p2).Include(p3);}/*******	operator<<(ostream& os, const XYRect& r) - Stream I/O for a XYRect spits out the *	values of bl and tr as a parenthesis-enclosed, comma-delimited pair, *	e.g., "((0,0),(1,1))".******/ostream& operator<<(ostream& os, const XYRect& r){	return os << "(" << (r.bl) << "," << (r.tr) << ")";}/********************************************************************************	Section 2: classes that represent reference marks and lines on a piece of paper*******************************************************************************//************	Paper - specialization of XYRect, used for representing the paper***********//*	Note: don't screw around with the order of Paper's member variables because	we rely on that order for constructor initialization. *//*******	Paper(double aWidth, double aHeight) - constructor sets the values of several*	other member variables that are useful to have around.******/Paper::Paper(double aWidth, double aHeight) : 	XYRect(0, 0, aWidth, aHeight), 	pWidth(aWidth), pHeight(aHeight),	botLeft(0, 0),	botRight(aWidth, 0),	topLeft(0, aHeight),	topRight(aWidth, aHeight),	topEdge(topLeft, topRight),	leftEdge(botLeft, topLeft),	rightEdge(botRight, topRight),	bottomEdge(botLeft, botRight),	upwardDiagonal(botLeft, topRight),	downwardDiagonal(topLeft, botRight){}/*******	Paper::ClipLine(const XYLine& al, XYPt& ap1, XYPt& ap2) - clip the line al to the paper,*	returning the endpoints of the clipped segment in ap1 and ap2. If the line misses the*	paper entirely, return false and leave ap1 and ap2 unchanged.******/const bool Paper::ClipLine(const XYLine& al, XYPt& ap1, XYPt& ap2) const{	// Start by collecting all points of intersection between the line and the	// four sides of the paper.		unsigned npts = 0;			// counter for number of points of intersection	XYPt ipts[4];				// list of points of intersection	XYPt p;						// a scratch pad for intersection points		if (topEdge.Intersects(al, p) && Encloses(p)) ipts[npts++] = p;	if (leftEdge.Intersects(al, p) && Encloses(p)) ipts[npts++] = p;	if (rightEdge.Intersects(al, p) && Encloses(p)) ipts[npts++] = p;	if (bottomEdge.Intersects(al, p) && Encloses(p)) ipts[npts++] = p;		if (npts == 0) return false;	// line entirely misses the paper	// Now parameterize all four points along the line, recording the minimum	// and maximum parameter values.		XYPt pt = al.d * al.u;					// a point on the line	XYPt up = al.u.Rotate90();				// a tangent to the line	double tmin =( ipts[0] - pt).Dot(up);	double tmax = tmin;	for (unsigned i = 1; i < npts; i++) {		double tt = (ipts[i] - pt).Dot(up);		if (tmin < tt) tmin = tt;		if (tmax > tt) tmax = tt;	};		// Compute the endpoints from our parameter ranges.		ap1 = pt + tmin * up;	ap2 = pt + tmax * up;	return true;}/*******	Paper::InteriorOverlaps(const XYLine& al) - return true if line al overlaps *	the paper in its interior. Return false if the line misses the paper entirely,*	only hits a corner, or only runs along an edge.******/const bool Paper::InteriorOverlaps(const XYLine& al) const{	XYPt pa, pb;								// endpoints of the fold line	if (!ClipLine(al, pa, pb)) return false;	// the line completely misses the paper		if (pa == pb) return false;					// line hits at a single point (a corner)		if (!BoundingBox(pa, pb).IsEmpty()) return true;	// bounding box has positive volume		// If still here, then the bounding box must be a line, either the edge of the paper	// or a vertical or horizontal line in the interior. We can test for the latter by 	// seeing if the midpoint of the line lies fully in the interior of the paper.		XYPt mp = MidPoint(pa, pb);		if (topEdge.Intersects(mp) || bottomEdge.Intersects(mp) || 		leftEdge.Intersects(mp) || rightEdge.Intersects(mp)) return false;		return true;}/*******	Paper::MakesSkinnyFlap(const XYLine& al) - The line al divides the paper into two*	portions. Return true if either of the two qualifies as a skinny flap. "Skinny" means*	a triangle (or quad) whose aspect ratio falls below a minimum size.******/const bool Paper::MakesSkinnyFlap(const XYLine& al) const	{	// Since "true" = "bad", we'll return true for any failures along the way due to bad	// input parameters.		XYPt p1, p2;						// endpoints of the line al	ClipLine(al, p1, p2);				// get the endpoints of the fold line on the paper		XYLine lb;							// perpendicular bisector of line segment p1-p2	lb.u = al.u.Rotate90();	lb.d = MidPoint(p1, p2).Dot(lb.u);	XYPt bp1, bp2;						// endpoints of the bisector	ClipLine(lb, bp1, bp2);				// get the endpoints of the bisector		// Get the bounding box that contains the fold line and a point on either side of the	// fold line. If this bounding box is below the minimum aspect ratio, then it contains	// a flap that falls below the minimum aspect ratio, so we return true.	if (abs(BoundingBox(p1, p2, bp1).GetAspectRatio()) < ReferenceFinder::minAspectRatio) 		return true;	if (abs(BoundingBox(p1, p2, bp2).GetAspectRatio()) < ReferenceFinder::minAspectRatio) 		return true;		// If we're still here, we didn't create any skinny flaps, so we're cool.		return false;}/************	class RefBase - base class for a mark or line. Non-static member variables are:*	mRank - the rank, which is the number of creases that need to be made to define it.*	mKey - a unique key that is used to efficiently store and search over marks and lines.*	mKey is initialized to 0. If the object has been successfully constructed, it will be set*	to an integer greater than 0, so mKey==0 is used as a test for successful construction.*	mIndex - a counter used in constructing the verbal sequence; basically, it's the order in*		which the object is created for a given folding sequence.**	Any subclasses of RefBase should be fairly lightweight because we'll be creating a couple *	hundred thousand of them during program initialization.***********//*******	RefBase static member initialization******/RefDgmr* RefBase::mDgmr;vector<RefBase*> RefBase::mSequence;vector<RefBase::DgmInfo> RefBase::mDgms;/*	Notes on Sequences.	A ref (RefMark or RefLine) is typically defined in terms of other refs, going all the way	back to RefMark_Original and RefLine_Original. The routine aRef->BuildAndNumberSequence()	constructs an ordered list of all the refs that make up aRef. The ordering is such that	ancestor refs come earlier in the list than refs derived from them. In addition to	constructing the list, BuildAndNumberSequence also sets the mIndex variable of each non-	original ref, so that each can be given a unique name (which depends on the index, and is	a letter, A-J for lines, P-Z for points).		This numbering scheme means that there can only be one sequence in existence at a time.	To insure this, the sequence is constructed in the static RefBase member variable mSequence,	which is public, so you can (if you like) read out this sequence.*//*******	RefBase::SequencePushSelf() - appends to the end of mSequence pointers to all the *	marks and lines needed to create this mark or line. Default behavior *	is to append a pointer to self.*	A subclass line or mark made from others should call SequencePushUnique() for each of *	the elements that define it, and then call the RefBase method for itself.******/void RefBase::SequencePushSelf(){	SequencePushUnique(this);}/*******	RefBase::BuildAndNumberSequence() - build a sequence (in mSequence) of all of the*	references that are needed to define this one; also set mIndex for each reference so*	that the relevant RefMarks and RefLines are sequentially numbered.******/void RefBase::BuildAndNumberSequence(){	// Clear out the old sequence		mSequence.clear();		// Build the sequence of marks and lines that go into making this object.	SequencePushSelf();			// Reset the counters for both marks and lines.		RefMark::ResetCount();	RefLine::ResetCount();	// go through the list of constituents and give every object a sequential index.		for (size_t i = 0; i < mSequence.size(); i++) mSequence[i]->SetIndex();}/*******	RefBase::SetClarifyVerbalAmbiguities(const bool f) - sets a flag; if true, then verbally*	ambiguous howto information includes extra info that resolves the ambiguity. Typically*	this will be true for text-only instruction, false for diagrammatic instruction.******/void RefBase::SetClarifyVerbalAmbiguities(const bool f){	clarifyVerbalAmbiguities = f;}/*******	RefBase::SetAxiomsInVerbalDirections(const bool f) - sets a flag; if true, then verbal*	directions will contain the axiom number.******/void RefBase::SetAxiomsInVerbalDirections(const bool f){	axiomsInVerbalDirections = f;}/*******	RefBase::PutHowto(ostream& os) - puts a statement about how to make this mark from its *	constituents to a stream. Overridden by most subclasses. Return true if we actually*	put something (original types will return false).******/const bool RefBase::PutHowto(ostream& /* os */) const{	return false;}/*******	RefBase::PutHowtoSequence(ostream& os) - sends the full how-to sequence to the given stream.******/ostream& RefBase::PutHowtoSequence(ostream& os){	// Build and number the sequence of marks and lines that go into making this object.	BuildAndNumberSequence();			// go through the sequence of references and print how to make the given mark or line.		for (size_t i = 0; i < mSequence.size(); i++)		if (mSequence[i]->PutHowto(os)) os << "." << endl;	return os;}		/*	Notes on diagrams.	A DgmInfo is a very simple object that contains just a couple of bits of information 	necessary to construct a complete diagram from the list of refs contained	in mSequence. Any diagram is a subsequence of mSequence, which, in effect, describes	all the refs that are already on the paper as well as the ref(s) currently being made. 		DgmInfo.idef is the index of the first ref in mSequence that is defined in the current	diagram.		DgmInfo.iact is the index of the last ref that is defined in the current diagram, 	which is the action line, if this diagram includes an action line. idef <= iact.*//*******	RefBase::BuildDiagrams() - Build a set of diagrams that describe how to fold this reference,*	by constructing a list of DgmInfo records (which refer to elements and subsequences of*	mSequence).******/void RefBase::BuildDiagrams(){	// Clear out the old set of diagrams		mDgms.clear();		// First, we need to build a sequence of all references that go into making this one.		BuildAndNumberSequence();		// Now, we need to note which elements of the sequence are action lines; there will be	// a diagram for each one of these.		size_t ss = mSequence.size();	for (size_t i = 0; i < ss; i++)		if (mSequence[i]->IsActionLine()) mDgms.push_back(DgmInfo(i, i));			// We should always have at least one diagram, even if there was only one ref in mSequence	// (which happens if the ref was a RefMark_Original or RefLine_Original).		if (mDgms.size() == 0) mDgms.push_back(DgmInfo(0, 0));		// And we make sure we have a diagram for the last ref in the sequence (which might not	// be the case if we ended with a RefMark or an original).		if (mDgms[mDgms.size() - 1].iact < ss - 1) mDgms.push_back(DgmInfo(0, ss - 1));		// Now we go through and set the idef fields of each DgmInfo record.		int id = 0;	for (size_t i = 0; i < mDgms.size(); i++) {		mDgms[i].idef = id;		id = mDgms[i].iact + 1;	}}/*******	RefBase::DrawPaper() - Draw the paper******/void RefBase::DrawPaper(){	vector<XYPt> corners;	corners.push_back(paper.botLeft);	corners.push_back(paper.botRight);	corners.push_back(paper.topRight);	corners.push_back(paper.topLeft);	mDgmr->DrawPoly(corners, RefDgmr::whitePoly);}/*******	RefBase::DrawDiagram(RefDgmr& aDgmr, const DgmInfo& aDgm) - draw the given diagram*	using the RefDgmr aDgmr.******/void RefBase::DrawDiagram(RefDgmr& aDgmr, const DgmInfo& aDgm){	// Set the current RefDgmr to be aDgmr.		mDgmr = &aDgmr;		// always draw the paper		DrawPaper();		// Make a note of the action line ref		RefBase* ral = mSequence[aDgm.iact];		// draw all refs specified by the DgmInfo. Most get drawn in normal style.	// The ref that is the action line (and all subsequent refs) get drawn in action style.	// Any refs that are used immediately by the action line get drawn in hilite style.	// Drawing for each diagram is done in multiple passes so that, for examples, labels end	// up on top of everything else.		for (short ipass = 0; ipass < maxPasses; ipass++) {		for (size_t i = 0; i < aDgm.iact; i++) {			RefBase* rb = mSequence[i];			if ((i >= aDgm.idef && rb->IsDerived()) || ral->UsesImmediate(rb)) 				rb->DrawSelf(hiliteRef, ipass);			else rb->DrawSelf(normalRef, ipass);		};		mSequence[aDgm.iact]->DrawSelf(actionRef, ipass);	}}/*******	RefBase::PutDiagramCaption(std::ostream& os, const DGMInfo& aDgm) - Put the caption to*	a particular diagram to a stream. The caption consists of how-to for those refs that*	are part of the action. The output is created as a single string containing possibly*	multiple sentences.******/void RefBase::PutDiagramCaption(std::ostream& os, const DgmInfo& aDgm){	for (size_t i = aDgm.idef; i <= aDgm.iact; i++) {		mSequence[i]->PutHowto(os);		os << ". ";	}}/*******	RefBase::UsesImmediate(RefBase* rb) - return true if this mark or line uses rb for *	immediate reference. "Immediate" means that if A uses B and B uses C, A->UsesImmediate(B)*	returns true but A->UsesImmediate(C) returns false. Default returns false; this will*	be used by original marks and lines.******/const bool RefBase::UsesImmediate(RefBase* /* rb */) const{	return false;}/*******	RefBase::IsDerived() -return true if this is a derived (rather than an original) mark*	or line. Note that this is not the same as mRank!=0, because the diagonals have mRank==1*	but are still considered original. Default is true since most objects will be derived.******/const bool RefBase::IsDerived() const{	return true;}/*******	RefBase::SequencePushUnique(RefBase* rb) - *	Utility used by subclasses when they implement SequencePushSelf(). This insures*	that a given mark only gets a single label.******/void RefBase::SequencePushUnique(RefBase* rb){	if (find(mSequence.begin(), mSequence.end(), rb) == mSequence.end()) mSequence.push_back(rb);}/************	RefMark - base class for a mark on the paper. ***********//*******	RefMark static member initialization******/RefBase::index_t RefMark::mCount = 0;		// Initialize class index/*******	RefMark::FinishConstructor() - Calculate the key value used for distinguishing RefMarks.*	This should be called at the end of every constructor if the mark is valid (and not*	if it isn't).******/void RefMark::FinishConstructor() {	const double fx = p.x / RefBase::paper.pWidth;	// fx is between 0 and 1	const double fy = p.y / RefBase::paper.pHeight;	// fy is between 0 and 1	key_t nx = static_cast<key_t> (floor(0.5 + fx * xNum));	key_t ny = static_cast<key_t> (floor(0.5 + fy * yNum));	mKey = 1 + nx * yNum + ny;}/*******	Distance(const XYPt& ap) - return the distance to a point ap. This is used when sorting*	marks by their distance from a given mark.******/const double RefMark::Distance(const XYPt& ap) const { 	return (p - ap).Mag(); } /*******	RefMark::IsOnEdge() - return true if this mark is on the edge of the paper******/const bool RefMark::IsOnEdge() const{	return (RefBase::paper.leftEdge.Intersects(p) || 		RefBase::paper.rightEdge.Intersects(p) ||		RefBase::paper.topEdge.Intersects(p) || 		RefBase::paper.bottomEdge.Intersects(p));}/*******	RefMark::IsActionLine() - return false, since marks can never be actions******/const bool RefMark::IsActionLine() const{	return false;}/*******	RefMark::KeySizeOK() - return true if the key_t type is large enough to hold all*	possible keys.******/const bool RefMark::KeySizeOK(){	return (xNum < numeric_limits<key_t>::max() / yNum);}/*******	RefMark::GetLabel() - return the label for this mark.******/const char RefMark::GetLabel() const{	return mLabels[mIndex - 1];}/*******	RefMark::PutName(ostream& os) - put the name of this mark to a stream. Default*	behavior gives this mark a letter. Return true if we used a letter, false if something*	else (i.e., the name of a RefMark_Original).******/const bool RefMark::PutName(ostream& os) const{	os << "point " << GetLabel();	return true;}/*******	RefMark::PutDistanceAndRank(ostream& os, const XYPt& ap) - put the distance from this mark*	to point ap to a stream.******/void RefMark::PutDistanceAndRank(ostream& os, const XYPt& ap) const{	os.precision(4);	os.setf(ios_base::fixed, ios_base::floatfield);	os << "Solution " << p.Chop() << ": err = " << Distance(ap) << " (rank " << mRank << ") ";}				/*******	RefMark::DrawSelf(RefStyle rstyle, short ipass) - Draw a RefMark in the indicated style******/void RefMark::DrawSelf(RefStyle rstyle, short ipass) const{	switch(ipass) {		case pointPass:			{				switch(rstyle) {					case normalRef:						mDgmr->DrawPt(p, RefDgmr::normalPt);						break;					case hiliteRef:						mDgmr->DrawPt(p, RefDgmr::hilitePt);						break;					case actionRef:						mDgmr->DrawPt(p, RefDgmr::actionPt);						break;				}			};			break;					case labelPass:			{			string sm(1, GetLabel());			switch(rstyle) {				case normalRef:					// Normal points don't get labels drawn					break;				case hiliteRef:					mDgmr->DrawLabel(p, sm, RefDgmr::hiliteLabel);					break;				case actionRef:					mDgmr->DrawLabel(p, sm, RefDgmr::actionLabel);					break;			};			break;		}	}}/*******	RefMark::SetIndex() - Most types of RefMark use the default method, which gives the mark*	an index from the class variable mCount and then bumps up the class variable.******/void RefMark::SetIndex(){	mIndex = ++mCount;}/*******	RefMark::ResetCount() - reset the static class variable mCount to zero.******/void RefMark::ResetCount(){	mCount = 0;}/************	RefMark_Original - Specialization of RefMark that represents a named mark*	(e.g., a corner).***********//*******	RefMark_Original::RefMark_Original(const XYPt& ap, rank_t arank, string as) - Constructor.******/RefMark_Original::RefMark_Original(const XYPt& ap, rank_t arank, string as) : 	RefMark(ap, arank), s(as){	FinishConstructor();}/*******	RefMark_Original::GetLabel() - return the label for this mark.******/const char RefMark_Original::GetLabel() const{	return 0;	// originals get no labels}/*******	RefMark_Original::PutName(ostream& os) - Put the name of this mark to a stream. Override*	to put the string name (rather than a letter).******/const bool RefMark_Original::PutName(ostream& os) const{	os << s;	// return the string	return false;}/*******	RefMark_Original::DrawSelf(RefStyle rstyle, short ipass) - Draw this mark******/void RefMark_Original::DrawSelf(RefStyle rstyle, short ipass) const{	// Override the default because original marks don't get labels and are only drawn	// when they are hilited or action (in which case we still draw them hilited).	if ((ipass == pointPass) && (rstyle == hiliteRef || rstyle == actionRef)) 		mDgmr->DrawPt(p, RefDgmr::hilitePt);}	/*******	RefMark_Original::IsDerived() - return false, since this is original******/const bool RefMark_Original::IsDerived() const{	return false;}/*******	RefMark_Original::SetIndex() - overridden because we don't use an index for named marks.******/void RefMark_Original::SetIndex(){	mIndex = 0;};/************	RefMark_Intersection - Specialization of a RefMark for a mark defined by the *	intersection of 2 lines.***********//*******	RefMark_Intersection(RefLine* arl1, RefLine* arl2) - Constructor.******/RefMark_Intersection::RefMark_Intersection(RefLine* arl1, RefLine* arl2) : 	RefMark(CalcMarkRank(arl1, arl2)), rl1(arl1), rl2(arl2){	// Get references to constituent math types		const XYLine& l1 = rl1->l;	const XYPt& u1 = rl1->l.u;//	const double& d1 = rl1->l.d;	const XYLine& l2 = rl2->l;	const XYPt& u2 = rl2->l.u;//	const double& d2 = rl2->l.d;			// If the lines don't intersect, it's not a valid point. If they do,	// assign the intersection to the member variable p.		if (!l1.Intersects(l2, p)) return;		// If the intersection point falls outside the square, it's not valid.		if (!RefBase::paper.Encloses(p)) return;		// If the lines intersect at less than a 30 degree angle, we won't keep this 	// point because such intersections are imprecise to use as reference points.		if (abs(u1.Dot(u2.Rotate90())) < ReferenceFinder::minAngleSine) return;			FinishConstructor();}/*******	RefMark_Intersection::UsesImmediate(RefBase* rb) - return true if this mark uses rb for *	immediate reference.******/const bool RefMark_Intersection::UsesImmediate(RefBase* rb) const{	return (rb == rl1 || rb == rl2);}/*******	RefMark_Intersection::SequencePushSelf() - Build the folding sequence*	that constructs this object.******/void RefMark_Intersection::SequencePushSelf(){	rl1->SequencePushSelf();	rl2->SequencePushSelf();	RefBase::SequencePushSelf();}/*******	RefMark_Intersection::PutHowto(ostream& os) - put a description of how to construct*	this mark.******/const bool RefMark_Intersection::PutHowto(ostream& os) const{	os << "The intersection of ";	rl1->PutName(os);	os << " with ";	rl2->PutName(os);	os << " is ";	PutName(os);	if (clarifyVerbalAmbiguities) {		os.precision(4);		os.setf(ios_base::fixed, ios_base::floatfield);		os << " = " << p.Chop();	};	return true;}/*******	RefMark_Intersection::MakeAll(rank_t arank) - Go*	through existing lines and create RefMark_Intersections with rank equal to arank, *	up to a cumulative total of maxMarks.******/void RefMark_Intersection::MakeAll(rank_t arank){	for (rank_t irank = 0; irank <= arank / 2; irank++) {		rank_t jrank = arank - irank;		bool sameRank = (irank == jrank);		RefContainer<RefLine>::rank_iterator li = ReferenceFinder::basisLines.maps[irank].begin();		if (sameRank) li++;		while (li != ReferenceFinder::basisLines.maps[irank].end()) {			RefContainer<RefLine>::rank_iterator lj = 				ReferenceFinder::basisLines.maps[jrank].begin();			while (lj != (sameRank ? li : ReferenceFinder::basisLines.maps[jrank].end())) { 				if (ReferenceFinder::basisMarks.TotalSize() >= ReferenceFinder::maxMarks) return;				RefMark_Intersection rmi(li->second, lj->second);				ReferenceFinder::basisMarks.AddCopyIfValidAndUnique(rmi);				lj++;			};			li++;		}	}	}/************	RefLine - base class for a reference line. ***********//*******	RefLine static member initialization******/RefBase::index_t RefLine::mCount = 0;		// Initialize class index/*******	RefLine::FinishConstructor()  - Calculate the key values used for sorting RefLines.*	Like its RefMark counterpart, this should be called at the end of every successfully*	constructed object, and it sets mKey to the proper value.******/void RefLine::FinishConstructor(){	// resolve the ambiguity in line orientation by requiring d>=0.		if (l.d < 0) {		l.d = -l.d;		l.u.x = -l.u.x;		l.u.y = -l.u.y;	};		double fa = (1. + atan2(l.u.y, l.u.x) / (3.14159265358979323)) / 2.0;	// fa is between 0 & 1	const double dmax = sqrt(pow(RefBase::paper.pWidth, 2) + 		pow(RefBase::paper.pHeight, 2));	const double fd = l.d / dmax;	// fd is between 0 and 1		key_t nd = static_cast <key_t> (floor(0.5 + fd * dNum));	if (nd == 0) fa = fmod(2 * fa, 1);	// for d=0, we map alpha and pi+alpha to the same key	key_t na = static_cast <key_t> (floor(0.5 + fa * aNum));	mKey = 1 + na * dNum + nd;}/*******	Distance (const XYLine& al) - return the "distance" between two lines, which is the *	Pythagorean	sum of the dot product of their direction vectors (roughly equivalent to *	angular separation)	and their distance scalars (roughly equivalent to parallel separation).******/const double RefLine::Distance (const XYLine& al) const{	return sqrt(pow(l.u.Dot(al.u.Rotate90()), 2) + pow(l.d - al.d * l.u.Dot(al.u), 2));}/*******	RefLine::IsOnEdge() - return true if this RefLine is on the edge of the paper******/const bool RefLine::IsOnEdge() const{	return ((RefBase::paper.leftEdge == l) || 		(RefBase::paper.topEdge == l) ||		(RefBase::paper.rightEdge == l) || 		(RefBase::paper.bottomEdge == l));}/*******	RefLine::IsActionLine() - return true, since MOST Reflines are actions******/const bool RefLine::IsActionLine() const{	return true;}/*******	RefLine::KeySizeOK() - return true if the key_t type is large enough to hold all*	possible keys.******/const bool RefLine::KeySizeOK(){	return aNum < numeric_limits<key_t>::max() / dNum;}/*******	RefLine::GetLabel() - return the label for this line.******/const char RefLine::GetLabel() const{	return mLabels[mIndex - 1];}/*******	RefLine::PutName(ostream& os) - put the name of this line to a stream. Default*	behavior gives this line a letter. Return true if we used a letter. (We'll*	return false if we use something else, i.e., a RefLine_Original).******/const bool RefLine::PutName(ostream& os) const{	os << "line " << GetLabel();	return true;}/*******	RefLine::PutDistanceAndRank(ostream& os, const XYLine& al) - put the distance *	between this line and line al to a stream along with the rank******/void RefLine::PutDistanceAndRank(ostream& os, const XYLine& al) const{	os.precision(4);	os.setf(ios_base::fixed, ios_base::floatfield);	os << "Solution " << l << ": err = " << Distance(al) << " (rank " << mRank << ") ";}				/*******	RefLine::DrawSelf(RefStyle rstyle, short ipass) - Draw a line in the given style.******/void RefLine::DrawSelf(RefStyle rstyle, short ipass) const{	XYPt p1, p2;	RefBase::paper.ClipLine(l, p1, p2);		switch(ipass) {		case linePass:			{				switch (rstyle) {					case normalRef:						mDgmr->DrawLine(p1, p2, RefDgmr::creaseLine);						break;					default: ; // keep compiler happy				}			};			break;					case hlinePass:	// hilited lines and action lines go on top of others			{				switch (rstyle) {					case hiliteRef:						mDgmr->DrawLine(p1, p2, RefDgmr::hiliteLine);						break;					case actionRef:						mDgmr->DrawLine(p1, p2, RefDgmr::valleyLine);						break;					default: ; // keep compiler happy				}			};			break;					case labelPass:			{				XYPt mp = MidPoint(p1, p2);	// label goes at the midpoint of the line				string sl(1, GetLabel());				switch (rstyle) {					case normalRef:						// normal lines don't get labels						break;					case hiliteRef:						mDgmr->DrawLabel(mp, sl, RefDgmr::hiliteLabel);						break;					case actionRef:						mDgmr->DrawLabel(mp, sl, RefDgmr::actionLabel);						break;					default: ;// keep compiler happy				}			};			break;		default: ;// keep compiler happy	}	// Subclasses will add arrows for actionRef}/*******	RefLine::SetIndex() - Most subclasses will use the default method, which sets the index*	from the class variable mCount and then bumps up the count.******/void RefLine::SetIndex(){	mIndex = ++mCount;}/*******	RefLine::ResetCount() - Reset the class variable mCount to zero.******/void RefLine::ResetCount(){	mCount = 0;}/************	RefLine_Original - Specialization of RefLine that represents a line that is the *	edge of the paper or an initial crease (like the diagonal).***********//*******	RefLine_Original::RefLine_Original(const XYLine& al, rank_t arank, string as) - Constructor.******/RefLine_Original::RefLine_Original(const XYLine& al, rank_t arank, string as) : 	RefLine(al, arank), s(as){	FinishConstructor();}/*******	RefLine_Original::IsActionLine() - return false because RefLine_Originals aren't actions,*	they're present from the beginning.******/const bool RefLine_Original::IsActionLine() const{	return false;}/*******	RefLine_Original::GetLabel() - return the label for this line.******/const char RefLine_Original::GetLabel() const{	return 0;	// originals get no label}/*******	RefLine_Original::PutName(ostream& os) - Put the name to a stream. Override the default*	method to use the actual string name, rather than a letter. Return false since we didn't*	use a letter.******/const bool RefLine_Original::PutName(ostream& os) const{	os << s;	return false;}/*******	RefLine_Original::DrawSelf(RefStyle rstyle, short ipass) - Draw this line *	in the appropriate style******/void RefLine_Original::DrawSelf(RefStyle rstyle, short ipass) const{		// RefLine_Originals don't get labels, and they are actionRef, we still draw them		// hilited.	XYPt p1, p2;	RefBase::paper.ClipLine(l, p1, p2);	switch(ipass) {		case linePass:			switch (rstyle) {				case normalRef:					mDgmr->DrawLine(p1, p2, RefDgmr::creaseLine);					break;				default: ; // keep compiler happy			}			break;		case hlinePass:			switch (rstyle) {				case hiliteRef:				case actionRef:					mDgmr->DrawLine(p1, p2, RefDgmr::hiliteLine);					break;				default: ; // keep compiler happy			}			break;		default: ; // keep compiler happy about unhandled cases	}}/*******	RefLine_Original::IsDerived() - return false, since this is original******/const bool RefLine_Original::IsDerived() const{	return false;}/*******	RefLine_Original::SetIndex() - set the index of this line. Override the default method*	to use an index of zero, since we've already got a name.******/void RefLine_Original::SetIndex(){	mIndex = 0;}/************	RefLine_C2P_C2P - Huzita-Hatori Axiom O1**	Make a crease through two points p1 and p2.***********//*******	RefLine_C2P_C2P(RefMark* arm1, RefMark* arm2) - Constructor. Initialize with the two*	marks that this line connects.******/RefLine_C2P_C2P::RefLine_C2P_C2P(RefMark* arm1, RefMark* arm2) : 	RefLine(CalcLineRank(arm1, arm2)), rm1(arm1), rm2(arm2){	// Get references to points		XYPt& p1 = rm1->p;	XYPt& p2 = rm2->p;		// Construct member data		l.u = (p2 - p1).Rotate90().Normalize();	l.d = .5 * (p1 + p2).Dot(l.u);		// Don't need to check visibility because this type is always visible.		// If this line creates a skinny flap, we won't use it.		if (RefBase::paper.MakesSkinnyFlap(l)) return;		// This type is always valid.		FinishConstructor();}/*******	RefLine_C2P_C2P::UsesImmediate(RefBase* rb) - return true if this line uses rb for *	immediate reference.******/const bool RefLine_C2P_C2P::UsesImmediate(RefBase* rb) const{	return (rb == rm1 || rb == rm2);}/*******	RefLine_C2P_C2P::SequencePushSelf() - Build the folding sequence*	that constructs this object.******/void RefLine_C2P_C2P::SequencePushSelf(){	rm1->SequencePushSelf();	rm2->SequencePushSelf();	RefBase::SequencePushSelf();}/*******	RefLine_C2P_C2P::PutHowto(ostream& os) - put the construction of this line to a stream.******/const bool RefLine_C2P_C2P::PutHowto(ostream& os) const{	if (axiomsInVerbalDirections) os << "[01] ";	os << "Form a crease connecting ";	rm1->PutName(os);	os << " with ";	rm2->PutName(os);	os << ", making ";	PutName(os);	return true;}/*******	RefLine_C2P_C2P::DrawSelf(RefStyle rstyle, short ipass) - Draw this line, *	adding arrows if appropriate******/void RefLine_C2P_C2P::DrawSelf(RefStyle rstyle, short ipass) const{	// Call the inherited method to draw the line		RefLine::DrawSelf(rstyle, ipass);		// If we're moving, we need arrows.		if ((ipass == arrowPass) && (rstyle == actionRef)) {			// Get the endpoints of the fold				XYPt& p1 = rm1->p;		XYPt& p2 = rm2->p;				// Get the perpendicular bisector of the fold				XYPt mp = MidPoint(p1, p2);		XYLine lb;		lb.u = l.u.Rotate90();		lb.d = mp.Dot(lb.u);				// Get the points where the bisector crosses the paper				XYPt p3, p4;		RefBase::paper.ClipLine(lb, p3, p4);				// Parameterize these points along the bisector. Don't care about sign.				double t3 = abs((p3 - mp).Dot(l.u));		double t4 = abs((p4 - mp).Dot(l.u));				// Construct a new pair of points that mate when folded and that are guaranteed to		// lie within the paper.				XYPt dp;		if (t3 < t4) dp = t3 * l.u;		else dp = t4 * l.u;		p3 = mp + dp;		p4 = mp - dp;				// Draw an arrow that connects these two points.				mDgmr->DrawFoldAndUnfoldArrow(p3, p4);	}}/*******	RefLine_C2P_C2P::MakeAll(rank_t arank) - Go*	through existing lines and marks and create RefLine_C2P_C2Ps with rank equal to arank,*	up to a cumulative total of maxLines.******/void RefLine_C2P_C2P::MakeAll(rank_t arank){	for (rank_t irank = 0; irank <= (arank - 1) / 2; irank++) {		rank_t jrank = arank - irank - 1;		bool sameRank = (irank == jrank);		RefContainer<RefMark>::rank_iterator mi = 			ReferenceFinder::basisMarks.maps[irank].begin();		if (sameRank) mi++;		while (mi != ReferenceFinder::basisMarks.maps[irank].end()) {			RefContainer<RefMark>::rank_iterator mj = 				ReferenceFinder::basisMarks.maps[jrank].begin();			while (mj != (sameRank ? mi : ReferenceFinder::basisMarks.maps[jrank].end())) {				if (ReferenceFinder::basisLines.TotalSize() >= ReferenceFinder::maxLines) return;				RefLine_C2P_C2P rlc(mi->second, mj->second);				ReferenceFinder::basisLines.AddCopyIfValidAndUnique(rlc);				mj++;			};			mi++;		}	}}/************	RefLine_P2P - Huzita-Hatori Axiom O2**	Bring p1 to p2.***********//*******	RefLine_P2P(RefMark* arm1, RefMark* arm2) - Constructor.******/RefLine_P2P::RefLine_P2P(RefMark* arm1, RefMark* arm2) : 	RefLine(CalcLineRank(arm1, arm2)), rm1(arm1), rm2(arm2){	// Get references to points		XYPt& p1 = rm1->p;	XYPt& p2 = rm2->p;		// Construct member data		l.u = (p2 - p1).Normalize();	l.d = .5 * (p1 + p2).Dot(l.u);		// Check visibility		bool p1edge = arm1->IsOnEdge();	bool p2edge = arm2->IsOnEdge();		if (ReferenceFinder::visibilityMatters) {		if (p1edge) whoMoves = p1Moves;		else if (p2edge) whoMoves = p2Moves;		else return;	}	else {		whoMoves = p1Moves;	};		// If this line creates a skinny flap, we won't use it.		if (RefBase::paper.MakesSkinnyFlap(l)) return;		// Set the key.	FinishConstructor();}/*******	RefLine_P2P::UsesImmediate(RefBase* rb) - return true if this line uses rb for *	immediate reference.******/const bool RefLine_P2P::UsesImmediate(RefBase* rb) const{	return (rb == rm1 || rb == rm2);}/*******	RefLine_P2P::SequencePushSelf() - Build the folding sequence*	that constructs this object.******/void RefLine_P2P::SequencePushSelf(){	switch (whoMoves) {		case p1Moves:			rm2->SequencePushSelf();			rm1->SequencePushSelf();			break;				case p2Moves:			rm1->SequencePushSelf();			rm2->SequencePushSelf();			break;	};			RefBase::SequencePushSelf();}/*******	RefLine_P2P::PutHowto(ostream& os) - put the construction of this line to a stream.******/const bool RefLine_P2P::PutHowto(ostream& os) const{	if (axiomsInVerbalDirections) os << "[02] ";	os << "Bring ";	switch (whoMoves) {		case p1Moves:			rm1->PutName(os);			os << " to ";			rm2->PutName(os);			break;					case p2Moves:			rm2->PutName(os);			os << " to ";			rm1->PutName(os);			break;	};	os << ", making ";	PutName(os);	return true;}/*******	RefLine_P2P::DrawSelf(RefStyle rstyle, short ipass) - Draw this line, *	adding arrows if appropriate******/void RefLine_P2P::DrawSelf(RefStyle rstyle, short ipass) const{	// Call inherited method to draw the lines		RefLine::DrawSelf(rstyle, ipass);		// If we're moving, we need an arrow		if ((ipass == arrowPass) && (rstyle == actionRef)) {		XYPt& p1 = rm1->p;		XYPt& p2 = rm2->p;		switch (whoMoves) {			case p1Moves:				mDgmr->DrawFoldAndUnfoldArrow(p1, p2);				break;			case p2Moves:				mDgmr->DrawFoldAndUnfoldArrow(p2, p1);				break;		}	}}			/*******	RefLine_P2P::MakeAll(rank_t arank) - Go*	through existing lines and marks and create RefLine_P2Ps with rank equal to arank,*	up to a cumulative total of maxLines.******/void RefLine_P2P::MakeAll(rank_t arank){	for (rank_t irank = 0; irank <= (arank - 1) / 2; irank++) {		rank_t jrank = arank - irank - 1;		bool sameRank = (irank == jrank);		RefContainer<RefMark>::rank_iterator mi = 			ReferenceFinder::basisMarks.maps[irank].begin();		if (sameRank) mi++;		while (mi != ReferenceFinder::basisMarks.maps[irank].end()) {			RefContainer<RefMark>::rank_iterator mj = 				ReferenceFinder::basisMarks.maps[jrank].begin();			while (mj != (sameRank ? mi : ReferenceFinder::basisMarks.maps[jrank].end())) {				if (ReferenceFinder::basisLines.TotalSize() >= ReferenceFinder::maxLines) return;				RefLine_P2P rlb(mi->second, mj->second);				ReferenceFinder::basisLines.AddCopyIfValidAndUnique(rlb);				mj++;			};			mi++;		}	}}/************	RefLine_L2L - Huzita-Hatori Axiom O3**	Bring line l1 to line l2.***********//*******	RefLine_L2L::RefLine_L2L(RefLine* arl1, RefLine* arl2, short iroot) - Constructor.*	iroot = 0 or 1.******/RefLine_L2L::RefLine_L2L(RefLine* arl1, RefLine* arl2, short iroot) : 	RefLine(CalcLineRank(arl1, arl2)), rl1(arl1), rl2(arl2){				// Get references to lines		XYLine& l1 = rl1->l;	XYPt& u1 = l1.u;	double& d1 = l1.d;	XYLine& l2 = rl2->l;	XYPt& u2 = l2.u;	double& d2 = l2.d;		// Parallel lines get handled specially. There's only one solution; we arbitrarily make	// it the iroot=0 solution.		if (l1.IsParallelTo(l2)) {		if (iroot == 0) {			l.u = u1;			l.d = .5 * (d1 + d2 * u2.Dot(u1));		}		else return; // iroot = 1 for parallel lines isn't a valid solution.	}	else {	// nonparallel lines			// Construct the direction vector for the bisector, depending on the value of iroot.				if (iroot == 0) l.u = (u1 + u2).Normalize();		else l.u = (u1 - u2).Normalize();				l.d = Intersection(l1, l2).Dot(l.u);	};		// If the paper doesn't overlap the fold line, we're not valid.		if (!RefBase::paper.InteriorOverlaps(l)) return;		// Check visibility		bool l1edge = arl1->IsOnEdge();	bool l2edge = arl2->IsOnEdge();		if (ReferenceFinder::visibilityMatters) {		if (l1edge) whoMoves = l1Moves;		else if (l2edge) whoMoves = l2Moves;		else {			XYPt lp1, lp2;			RefBase::paper.ClipLine(l1, lp1, lp2);			if (RefBase::paper.Encloses(l.Fold(lp1)) && 				RefBase::paper.Encloses(l.Fold(lp2))) whoMoves = l1Moves;			else {				RefBase::paper.ClipLine(l2, lp1, lp2);				if (RefBase::paper.Encloses(l.Fold(lp1)) && 					RefBase::paper.Encloses(l.Fold(lp2))) whoMoves = l2Moves;				else return;			}		}	}	else {		whoMoves = l1Moves;	};		// If this line creates a skinny flap, we won't use it.		if (RefBase::paper.MakesSkinnyFlap(l)) return;	// Set the key.		FinishConstructor();}/*******	RefLine_L2L::UsesImmediate(RefBase* rb) - return true if this line uses rb for *	immediate reference.******/const bool RefLine_L2L::UsesImmediate(RefBase* rb) const{	return (rb == rl1 || rb == rl2);}/*******	RefLine_L2L::SequencePushSelf() - Build the folding sequence*	that constructs this object.******/void RefLine_L2L::SequencePushSelf(){	switch (whoMoves) {		case l1Moves:			rl2->SequencePushSelf();			rl1->SequencePushSelf();			break;				case l2Moves:			rl1->SequencePushSelf();			rl2->SequencePushSelf();			break;	};	RefBase::SequencePushSelf();}/*******	RefLine_L2L::PutHowto(ostream& os) - put the construction of this line to a stream.******/const bool RefLine_L2L::PutHowto(ostream& os) const{	if (axiomsInVerbalDirections) os << "[03] ";	os << "Fold ";	switch (whoMoves) {		case l1Moves:			rl1->PutName(os);			os << " to ";			rl2->PutName(os);					break;				case l2Moves:			rl2->PutName(os);			os << " to ";			rl1->PutName(os);					break;	};	os << ", making ";	PutName(os);	if (clarifyVerbalAmbiguities) {		os << " through ";				// Now we need to specify which of the two bisectors this is, which we do		// by specifying a point where the bisector hits the edge of the square.				XYPt p;		rl1->l.Intersects(rl2->l, p);	// get the intersection of the two bisectors		XYPt pa, pb;		RefBase::paper.ClipLine(l, pa, pb);		// find where our fold line hits the paper.				// Return the first point of intersection between the fold line and the edge of the		// paper that _isn't_ the intersection of the two bisectors.				os.precision(2);		os.setf(ios_base::fixed, ios_base::floatfield);		if (p == pa) return os << pb.Chop();		os << pa.Chop();	};	return true;}/*******	RefLine_L2L::DrawSelf(RefStyle rstyle, short ipass) - Draw this line, adding arrows if appropriate******/void RefLine_L2L::DrawSelf(RefStyle rstyle, short ipass) const{	// Call inherited method to draw the lines		RefLine::DrawSelf(rstyle, ipass);		// If we're moving, we need an arrow that brings two points from one line to two points on	// the other line. We need to pick points that are within the paper for both lines.		if ((ipass == arrowPass) && (rstyle == actionRef)) {						XYLine& l1 = rl1->l;			XYLine& l2 = rl2->l;			XYPt p1a, p1b;			RefBase::paper.ClipLine(l1, p1a, p1b);	// endpoints of l1			XYPt p2a, p2b;			RefBase::paper.ClipLine(l2, p2a, p2b);	// endpoints of l2			p2a = l.Fold(p2a);								// flop l2 points onto l1			p2b = l.Fold(p2b);			XYPt du1 = l1.d * l1.u;				// a point on l1			XYPt up1 = l1.u.Rotate90();			// a tangent to l1			vector<double> tvals;				// holds parameterizations of the 4 points			tvals.push_back((p1a - du1).Dot(up1));	// parameterize p1a along l1			tvals.push_back((p1b - du1).Dot(up1));	// parameterize p1b along l1			tvals.push_back((p2a - du1).Dot(up1));	// parameterize p2a along l1			tvals.push_back((p2b - du1).Dot(up1));	// parameterize p2b along l1			sort(tvals.begin(), tvals.end());		// sort them in order; we want the middle 2			XYPt p1c = du1 + 0.5 * (tvals[1] + tvals[2]) * up1;			XYPt p2c = l.Fold(p1c);			switch(whoMoves) {				case l1Moves:					mDgmr->DrawFoldAndUnfoldArrow(p1c, p2c);					break;				case l2Moves:					mDgmr->DrawFoldAndUnfoldArrow(p1c, p2c);					break;			}	}}/*******	RefLine_L2L::MakeAll(rank_t arank) - Go*	through existing lines and marks and create RefLine_L2Ls with rank equal to arank*	up to a cumulative total of maxLines.******/void RefLine_L2L::MakeAll(rank_t arank){	for (rank_t irank = 0; irank <= (arank - 1) / 2; irank++) {		rank_t jrank = arank - irank - 1;		bool sameRank = (irank == jrank);		RefContainer<RefLine>::rank_iterator li = ReferenceFinder::basisLines.maps[irank].begin();		if (sameRank) li++;		while (li != ReferenceFinder::basisLines.maps[irank].end()) {			RefContainer<RefLine>::rank_iterator lj = 				ReferenceFinder::basisLines.maps[jrank].begin();			while (lj != (sameRank ? li : ReferenceFinder::basisLines.maps[jrank].end())) {				if (ReferenceFinder::basisLines.TotalSize() >= ReferenceFinder::maxLines) return;				RefLine_L2L rls1(li->second, lj->second, 0);				ReferenceFinder::basisLines.AddCopyIfValidAndUnique(rls1);				if (ReferenceFinder::basisLines.TotalSize() >= ReferenceFinder::maxLines) return;				RefLine_L2L rls2(li->second, lj->second, 1);				ReferenceFinder::basisLines.AddCopyIfValidAndUnique(rls2);				lj++;			};			li++;		}	}}/************	RefLine_L2L_C2P - Huzita-Hatori Axiom O4**	Bring line l1 to itself so that the crease goes through point p1***********//*******	RefLine_L2L_C2P::RefLine_L2L_C2P(RefLine* arl1, RefMark* arm1) - Constructor.******/RefLine_L2L_C2P::RefLine_L2L_C2P(RefLine* arl1, RefMark* arm1) : 	RefLine(CalcLineRank(arl1, arm1)), rl1(arl1), rm1(arm1){				// Get references to line and mark		XYPt& u1 = rl1->l.u;	double& d1 = rl1->l.d;	XYPt& p1 = rm1->p;		// Construct the direction vector and distance scalar for the fold line.		l.u = u1.Rotate90();	l.d = p1.Dot(l.u);	// The intersection of the fold line with line l1 must be enclosed in the paper.	// That point is the projection of p1 onto line l1.		XYPt p1p = p1 + (d1 - (p1.Dot(u1))) * u1;	if (!RefBase::paper.Encloses(p1p)) return;		// Don't need to check visibility, this kind is always visible.		// If this line creates a skinny flap, we won't use it.		if (RefBase::paper.MakesSkinnyFlap(l)) return;		// Set the key.		FinishConstructor();}/*******	RefLine_L2L_C2P::UsesImmediate(RefBase* rb) - return true if this line uses rb for *	immediate reference.******/const bool RefLine_L2L_C2P::UsesImmediate(RefBase* rb) const{	return (rb == rl1 || rb == rm1);}/*******	RefLine_L2L_C2P::SequencePushSelf() - Build the folding sequence*	that constructs this object.******/void RefLine_L2L_C2P::SequencePushSelf(){	rm1->SequencePushSelf();	rl1->SequencePushSelf();	RefBase::SequencePushSelf();}/*******	RefLine_L2L_C2P::PutHowto(ostream& os) - put the construction of this line to a stream.******/const bool RefLine_L2L_C2P::PutHowto(ostream& os) const{	if (axiomsInVerbalDirections) os << "[04] ";	os << "Fold ";	rl1->PutName(os);	os << " onto itself, making ";	PutName(os);	os << " through ";	rm1->PutName(os);	return true;}/*******	RefLine_L2L_C2P::DrawSelf(RefStyle rstyle, short ipass) - Draw this line, *	adding arrows if appropriate******/void RefLine_L2L_C2P::DrawSelf(RefStyle rstyle, short ipass) const{	// Call inherited method to draw the lines		RefLine::DrawSelf(rstyle, ipass);		// If we're moving, we need an arrow		if ((ipass == arrowPass) && (rstyle == actionRef)) {						XYPt p1, p2;			XYLine& l1 = rl1->l;			RefBase::paper.ClipLine(l1, p1, p2);	// get endpts of the reference line			XYPt pi = Intersection(l, l1);					// intersection w/ fold line			XYPt u1p = l1.u.Rotate90();						// tangent to reference line			double t1 = abs((p1 - pi).Dot(u1p));			double t2 = abs((p2 - pi).Dot(u1p));			double tmin = t1 < t2 ? t1 : t2;			mDgmr->DrawFoldAndUnfoldArrow(pi + tmin * u1p, pi - tmin * u1p);	}}/*******	RefLine_L2L_C2P::MakeAll(rank_t arank) - Go*	through existing lines and marks and create RefLine_L2L_C2Ps with rank equal to arank*	up to a cumulative total of maxLines.******/void RefLine_L2L_C2P::MakeAll(rank_t arank){	for (rank_t irank = 0; irank <= (arank - 1); irank++) {		rank_t jrank = arank - irank - 1;		RefContainer<RefLine>::rank_iterator li = 			ReferenceFinder::basisLines.maps[irank].begin();		while (li != ReferenceFinder::basisLines.maps[irank].end()) {			RefContainer<RefMark>::rank_iterator mj = 				ReferenceFinder::basisMarks.maps[jrank].begin();			while (mj != ReferenceFinder::basisMarks.maps[jrank].end()) {				if (ReferenceFinder::basisLines.TotalSize() >= ReferenceFinder::maxLines) return;				RefLine_L2L_C2P rls1(li->second, mj->second);				ReferenceFinder::basisLines.AddCopyIfValidAndUnique(rls1);				mj++;			};			li++;		}	}}/************	RefLine_P2L_C2P - Huzita-Hatori Axiom O5.**	Bring point p1 to line l1 so that the crease passes through point p2.***********//*******	RefLine_P2L_C2P::RefLine_P2L_C2P(RefMark* arm1, RefLine* arl1, RefMark* arm2, short iroot) - *	Constructor. iroot can be 0 or 1.******/RefLine_P2L_C2P::RefLine_P2L_C2P(RefMark* arm1, RefLine* arl1, RefMark* arm2, short iroot) :	RefLine(CalcLineRank(arm1, arl1, arm2)), rm1(arm1), rl1(arl1), rm2(arm2){	// Get references to the points and lines.		XYPt& p1 = rm1->p;	XYLine& l1 = rl1->l;	XYPt& u1 = l1.u;	double& d1 = l1.d;	XYPt& p2 = rm2->p;	// If either point is already on the line, then this isn't interesting, i.e., it's	// a trivial Haga construction.		if (l1.Intersects(p1) || l1.Intersects(p2)) return;		// Construct the line.		double a = d1 - p2.Dot(u1);	double b2 = (p2 - p1).Mag2() - a * a;		if (b2 < 0) return;		// no solution for negative b2 (implies imaginary b)		double b = sqrt(b2);	if ((b < EPS) && (iroot == 1)) return;	// degenerate case, there's only one solution		// Construct the image of p1 (p1p), which depends on which root we're after.		XYPt u1p = u1.Rotate90();	XYPt p1p = p2 + a * u1;	if (iroot == 0) p1p += b * u1p;	else p1p -= b * u1p;		// Validate; the point of incidence must lie within the square.		if (!RefBase::paper.Encloses(p1p)) return;		// Construct member data.	l.u = (p1p - p1).Normalize();	l.d = p2.Dot(l.u);		// Check visibility.		bool p1edge = arm1->IsOnEdge();	bool l1edge = arl1->IsOnEdge();		if (ReferenceFinder::visibilityMatters) {		if (p1edge) whoMoves = p1Moves;		else if (l1edge) whoMoves = l1Moves;		else return;	}	else {		whoMoves = p1Moves;	};		// If this line creates a skinny flap, we won't use it.		if (RefBase::paper.MakesSkinnyFlap(l)) return;		// Set the key.		FinishConstructor();}/*******	RefLine_P2L_C2P::UsesImmediate(RefBase* rb) - return true if this line uses rb for *	immediate reference.******/const bool RefLine_P2L_C2P::UsesImmediate(RefBase* rb) const{	return (rb == rl1 || rb == rm1 || rb == rm2);}/*******	RefLine_P2L_C2P::SequencePushSelf() - Build the folding sequence*	that constructs this object.******/void RefLine_P2L_C2P::SequencePushSelf(){	rm2->SequencePushSelf();	switch (whoMoves) {		case p1Moves:			rl1->SequencePushSelf();			rm1->SequencePushSelf();			break;					case l1Moves:			rm1->SequencePushSelf();			rl1->SequencePushSelf();			break;	};	RefBase::SequencePushSelf();}/*******	RefLine_P2L_C2P::PutHowto(ostream& os) - Put the name of this line to a stream.******/const bool RefLine_P2L_C2P::PutHowto(ostream& os) const{	if (axiomsInVerbalDirections) os << "[05] ";	os << "Bring ";	switch (whoMoves) {		case p1Moves:			rm1->PutName(os);			os << " to ";			rl1->PutName(os);			break;				case l1Moves:			rl1->PutName(os);			os << " to ";			rm1->PutName(os);			break;	};	if (clarifyVerbalAmbiguities) {				os << " so the crease goes through ";		rm2->PutName(os);	};	os << ", making ";	PutName(os);	return true;}/*******	RefLine_P2L_C2P::DrawSelf(RefStyle rstyle, short ipass) - Draw this line, *	adding arrows if appropriate******/void RefLine_P2L_C2P::DrawSelf(RefStyle rstyle, short ipass) const{	// Call inherited method to draw the lines		RefLine::DrawSelf(rstyle, ipass);		// If we're moving, we need an arrow		if ((ipass == arrowPass) && (rstyle == actionRef)) {					XYPt& p1 = rm1->p;		XYPt p1f = l.Fold(p1);		switch (whoMoves) {			case p1Moves:				mDgmr->DrawFoldAndUnfoldArrow(p1, p1f);				break;			case l1Moves:				mDgmr->DrawFoldAndUnfoldArrow(p1f, p1);				break;		}	}}/*******	RefLine_P2L_C2P::MakeAll(rank_t arank) - Go*	through existing lines and marks and create RefLine_P2L_C2Ps with rank equal arank*	up to a cumulative total of maxLines.******/void RefLine_P2L_C2P::MakeAll(rank_t arank){	for (rank_t irank = 0; irank <= (arank - 1); irank++)		for (rank_t jrank = 0; jrank <= (arank - 1 - irank); jrank++) {			rank_t krank = arank - irank - jrank - 1;			RefContainer<RefMark>::rank_iterator mi = 				ReferenceFinder::basisMarks.maps[irank].begin();			while (mi != ReferenceFinder::basisMarks.maps[irank].end()) {				RefContainer<RefLine>::rank_iterator lj = 					ReferenceFinder::basisLines.maps[jrank].begin();				while (lj != ReferenceFinder::basisLines.maps[jrank].end()) {					RefContainer<RefMark>::rank_iterator mk = 						ReferenceFinder::basisMarks.maps[krank].begin();					while (mk != ReferenceFinder::basisMarks.maps[krank].end()) {						if (mi != mk) {							if (ReferenceFinder::basisLines.TotalSize() >= 								ReferenceFinder::maxLines) return;							RefLine_P2L_C2P rlh1(mi->second, lj->second, mk->second, 0);							ReferenceFinder::basisLines.AddCopyIfValidAndUnique(rlh1);							if (ReferenceFinder::basisLines.TotalSize() >= 								ReferenceFinder::maxLines) return;							RefLine_P2L_C2P rlh2(mi->second, lj->second, mk->second, 1);							ReferenceFinder::basisLines.AddCopyIfValidAndUnique(rlh1);						};						mk++;					};					lj++;				};				mi++;			}		}}/************	RefLine_P2L_P2L - Huzita-Hatori Axiom O6.**	Bring point p1 to line l1 and point p2 to line l2.***********//*******	RefLine_P2L_P2L static member initialization******/short RefLine_P2L_P2L::order = 0;short RefLine_P2L_P2L::irootMax = 0;double RefLine_P2L_P2L::q1 = 0;double RefLine_P2L_P2L::q2 = 0;double RefLine_P2L_P2L::S = 0;double RefLine_P2L_P2L::Sr = 0;double RefLine_P2L_P2L::Si = 0;double RefLine_P2L_P2L::U = 0;/*******	CubeRoot(double x) - works for both positive and negative numbers******/double CubeRoot(double x){	if (x >= 0) return pow(x, 1./3);	else return -pow(-x, 1./3);}/*******	RefLine_P2L_P2L::RefLine_P2L_P2L(RefMark* arm1, RefLine* arl1, RefMark* arm2, RefLine* arl2, *		short iroot) - Constructor. Variable iroot can be 0, 1, or 2.******/RefLine_P2L_P2L::RefLine_P2L_P2L(RefMark* arm1, RefLine* arl1, RefMark* arm2, RefLine* arl2, 	short iroot) : 	RefLine(CalcLineRank(arm1, arl1, arm2, arl2)), rm1(arm1), rl1(arl1), rm2(arm2), rl2(arl2){	// Get references to the points and lines involved in the construction		XYPt& p1 = rm1->p;	XYLine& l1 = rl1->l;	XYPt& u1 = l1.u;	double& d1 = l1.d;	XYPt& p2 = rm2->p;	XYLine& l2 = rl2->l;	XYPt& u2 = l2.u;	double& d2 = l2.d;	// This is by far the most complex alignment, and it involves the solution of a cubic equation.		XYPt u1p = u1.Rotate90();	// we'll need this later.		// First, some trivial checks; we can't have p1 already on l1, or p2 already on l2.		if (l1.Intersects(p1)) return;	if (l2.Intersects(p2)) return;		// Also make sure we're using distinct points and lines.		if ((p1 == p2) || (l1 == l2)) return;		// Now construct the terms of the cubic equation. These are stored in static member variables	// during the iroot==0 construction; if iroot==1 or 2, we used the stored values.	double rc = 0;	// this will hold the root of the cubic equation after this switch(iroot).	switch (iroot) {		case 0:			{					// case iroot==0 computes a bunch of quantities that are used for all roots.				// Some of these get stored in private static member variables.								XYPt v1 = p1 + d1 * u1 - 2 * p2;				XYPt v2 = d1 * u1 - p1;				double c1 = p2.Dot(u2) - d2;				double c2 = 2 * v2.Dot(u1p);				double c3 = v2.Dot(v2);				double c4 = (v1 + v2).Dot(u1p);				double c5 = v1.Dot(v2);				double c6 = u1p.Dot(u2);				double c7 = v2.Dot(u2);								// the equation is a * r^3 + b * r^2 + c * r + d == 0								double a = c6;				double b = c1 + c4 * c6 + c7;				double c = c1 * c2 + c5 * c6 + c4 * c7;				double d = c1 * c3 + c5 * c7;						// compute the order of the equation								if (abs(a) > EPS) order = 3;		// cubic equation				else if (abs(b) > EPS) order = 2;	// quadratic equation				else if (abs(c) > EPS) order = 1;	// linear equation				else order = 0;						// ill-formed equation (no variables!)								// what we do next depends on the order of the equation.								switch(order) {					case 0:				// ill-formed equation has 0 roots						return;										case 1:				// linear equation has 1 root						{							rc = -d / c;						}						break;										case 2:				// quadratic equation has 0, 1 or 2 roots						{											double disc = pow(c, 2) - 4 * b * d;							q1 = -c / (2 * b);							if (disc < 0) {								irootMax = -1;				// no roots								return;							}							else if (abs(disc) < EPS) {								irootMax = 0;				// 1 degenerate root								rc = q1;					// and here it is							}							else {								irootMax = 1;				// 2 roots								q2 = sqrt(disc) / (2 * b);								rc = q1 + q2;				// and here's the first							}						}						break;									case 3:				// cubic equation, has 1, 2, or 3 roots						{							// Construct coefficients that give the roots from Cardano's formula.														double a2 = b / a;							double a1 = c / a;							double a0 = d / a;														double Q = (3 * a1 - pow(a2, 2)) / 9;							double R = (9 * a2 * a1 - 27 * a0 - 2 * pow(a2, 3)) / 54;							double D = pow(Q, 3) + pow(R, 2);							U = -a2 / 3;														// The number of roots depends on the value of D.														if (D > 0) {								irootMax = 0;				// one root								double rD = sqrt(D);								S = CubeRoot(R + rD);								double T = CubeRoot(R - rD);								rc = U + S + T;				// and here it is.							}							else if (abs(D) < EPS) {								irootMax = 1;				// two roots								S = pow(R, 1./3);								rc = U + 2 * S;				// here's the first							}							else { // D < 0								irootMax = 2;				// three roots								double rD = sqrt(-D);								double phi = atan2(rD, R) / 3;								double rS = pow(pow(R, 2) - D, 1./6);								Sr = rS * cos(phi);								Si = rS * sin(phi);								rc = U + 2 * Sr;			// here's the first							}						}						break;	// end of case 3 of order					}			}					break;	// end of case 0 of iroot		// for the other two roots, we'll rely on the fact that the coefficients		// of the equation and first root have already been constructed.				case 1: // of iroot, meaning we're looking for the second root					if (irootMax < 1) return;			switch(order) {				case 2:					rc = q1 - q2;		// second root of a quadratic					break;								case 3:					// second root of a cubic					if (irootMax == 1)						rc = U - S;					else // irootMax == 2						rc = U - Sr - sqrt(3.) * Si;					break;			};			break;	// end of case 1 of iroot				case 2:	// of iroot, meaning we're looking for the third root					if (irootMax < 2) return;			switch(order) {				case 3:					// third root of a cubic					rc = U - Sr + sqrt(3.) * Si;					break;			};			break;	// end of case 2 of iroot				};	// end of switch(iroot).		// If we're here, rc contains a root of the equation, which must still be validated.				XYPt p1p = d1 * u1 + rc * u1p;					// image of p1 in fold line		if (p1p == p1) return;							// we only consider p1 off of the fold line		l.u = (p1p - p1).Normalize();					// normal to fold line	l.d = l.u.Dot(MidPoint(p1p, p1));				// d-parameter of fold line	XYPt p2p = p2 + 2 * (l.d - p2.Dot(l.u)) * l.u;	// image of p2 in fold line		// Validate; the images of p1 and p2 must lie within the square.		if (!RefBase::paper.Encloses(p1p) || !RefBase::paper.Encloses(p2p)) return;		// Validate visibility; we require that the alignment be visible even with opaque paper.	// Meaning that the moving parts must be edge points or edge lines.		// Note whether p1 and p2 are on the same side of the fold line. If they are, then either	// both points move or both lines move. If they're not, then one of each moves.		bool sameSide = ((p1.Dot(l.u) - l.d) * (p2.Dot(l.u) - l.d) >= 0);		// Note which points and lines are on the edge of the paper		bool p1edge = rm1->IsOnEdge();	bool p2edge = rm2->IsOnEdge();	bool l1edge = rl1->IsOnEdge();	bool l2edge = rl2->IsOnEdge();		// Now, check the visibility of this alignment and use it to specify which parts move		if (ReferenceFinder::visibilityMatters) {		if (sameSide)			if (p1edge && p2edge) whoMoves = p1p2Moves;			else if (l1edge && l2edge) whoMoves = l1l2Moves;			else return;		else			if (p1edge && l2edge) whoMoves = p1l2Moves;			else if (p2edge && l1edge) whoMoves = p2l1Moves;			else return;	}	else {		if (sameSide) whoMoves = p1p2Moves;		else whoMoves = p1l2Moves;	};		// If this line creates a skinny flap, we won't use it.		if (RefBase::paper.MakesSkinnyFlap(l)) return;		// Set the key.		FinishConstructor();}/*******	RefLine_P2L_P2L::UsesImmediate(RefBase* rb) - return true if this line uses rb for *	immediate reference.******/const bool RefLine_P2L_P2L::UsesImmediate(RefBase* rb) const{	return (rb == rl1 || rb == rm1 || rb == rl2 || rb == rm2);}/*******	RefLine_P2L_P2L::SequencePushSelf() - Build the folding sequence*	that constructs this object.******/void RefLine_P2L_P2L::SequencePushSelf(){	switch (whoMoves) {		case p1p2Moves:			rl2->SequencePushSelf();			rl1->SequencePushSelf();			rm2->SequencePushSelf();			rm1->SequencePushSelf();			break;					case l1l2Moves:			rm2->SequencePushSelf();			rm1->SequencePushSelf();			rl2->SequencePushSelf();			rl1->SequencePushSelf();			break;				case p1l2Moves:			rm2->SequencePushSelf();			rl1->SequencePushSelf();			rl2->SequencePushSelf();			rm1->SequencePushSelf();			break;				case p2l1Moves:			rl2->SequencePushSelf();			rm1->SequencePushSelf();			rl1->SequencePushSelf();			rm2->SequencePushSelf();			break;	};	RefBase::SequencePushSelf();}/*******	RefLine_P2L_P2L::PutHowto(ostream& os) - Put the name of this line to a stream.******/const bool RefLine_P2L_P2L::PutHowto(ostream& os) const{	if (axiomsInVerbalDirections) os << "[06] ";	os.precision(2);	os.setf(ios_base::fixed, ios_base::floatfield);	os << "Bring ";	switch (whoMoves) {		case p1p2Moves:			rm1->PutName(os);			os << " to ";			rl1->PutName(os);			if (clarifyVerbalAmbiguities)				os << " at point " << l.Fold(rm1->p).Chop();			os << " and ";			rm2->PutName(os);			os << " to ";			rl2->PutName(os);			break;				case l1l2Moves:			rl1->PutName(os);			if (clarifyVerbalAmbiguities)				os << " so that point " << l.Fold(rm1->p).Chop();			os << " touches ";			rm1->PutName(os);			os << " and ";			rl2->PutName(os);			os << " to ";			rm2->PutName(os);			break;				case p1l2Moves:			rm1->PutName(os);			os << " to ";			rl1->PutName(os);			if (clarifyVerbalAmbiguities)				os << " at point " << l.Fold(rm1->p).Chop();			os << " and ";			rl2->PutName(os);			os << " to ";			rm2->PutName(os);			break;				case p2l1Moves:			rl1->PutName(os);			os << " to ";			rm1->PutName(os);			os << " and ";			rm2->PutName(os);			os << " to ";			rl2->PutName(os);			if (clarifyVerbalAmbiguities)				os << " at point " << l.Fold(rm2->p).Chop();			break;	};	os << ", making ";	PutName(os);	return true;}/*******	RefLine_P2P_P2L::DrawSelf(RefStyle rstyle, short ipass) - Draw this line, *	adding arrows if appropriate******/void RefLine_P2L_P2L::DrawSelf(RefStyle rstyle, short ipass) const{	// Call inherited method to draw the lines		RefLine::DrawSelf(rstyle, ipass);		// If we're moving, we need an arrow		if ((ipass == arrowPass) && (rstyle == actionRef)) {							XYPt& p1a = rm1->p;				XYPt p1b = l.Fold(p1a);				XYPt& p2a = rm2->p;				XYPt p2b = l.Fold(p2a);		switch (whoMoves) {			case p1p2Moves:				mDgmr->DrawFoldAndUnfoldArrow(p1a, p1b);				mDgmr->DrawFoldAndUnfoldArrow(p2a, p2b);				break;							case l1l2Moves:				mDgmr->DrawFoldAndUnfoldArrow(p1b, p1a);				mDgmr->DrawFoldAndUnfoldArrow(p2b, p2a);				break;						case p1l2Moves:				mDgmr->DrawFoldAndUnfoldArrow(p1a, p1b);				mDgmr->DrawFoldAndUnfoldArrow(p2b, p2a);				break;						case p2l1Moves:				mDgmr->DrawFoldAndUnfoldArrow(p1b, p1a);				mDgmr->DrawFoldAndUnfoldArrow(p2a, p2b);				break;		}	}}/*******	RefLine_P2L_P2L::MakeAll(rank_t arank) - Go*	through existing lines and marks and create RefLine_P2L_P2Ls with rank equal arank*	up to a cumulative total of maxLines.******/void RefLine_P2L_P2L::MakeAll(rank_t arank){	// psrank == sum of ranks of the two points	// lsrank == sum of ranks of the two lines		for (rank_t psrank = 0; psrank <= (arank - 1); psrank++)		for (rank_t lsrank = 0; lsrank <= (arank - 1) - psrank; lsrank++)			// point order doesn't matter, so rank(pt[i]) will always be <= rank(pt[j])			for (rank_t irank = 0; irank <= psrank / 2; irank++) {				rank_t jrank = psrank - irank;				bool psameRank = (irank == jrank);								// line order does matter, so both lines vary over all ranks								for (rank_t krank = 0; krank <= lsrank; krank++)					for (rank_t lrank = 0; lrank <= lsrank - krank; lrank++) {								// iterate over all combinations of points & lines with given rank								RefContainer<RefMark>::rank_iterator mi = 							ReferenceFinder::basisMarks.maps[irank].begin();						if (psameRank) mi++;						while (mi != ReferenceFinder::basisMarks.maps[irank].end()) {							RefContainer<RefMark>::rank_iterator mj = 								ReferenceFinder::basisMarks.maps[jrank].begin();							while (mj != (psameRank ? mi : 								ReferenceFinder::basisMarks.maps[jrank].end())) {								RefContainer<RefLine>::rank_iterator lk = 									ReferenceFinder::basisLines.maps[krank].begin();								while (lk != ReferenceFinder::basisLines.maps[krank].end()) {									RefContainer<RefLine>::rank_iterator ll = 										ReferenceFinder::basisLines.maps[lrank].begin();									while (ll != ReferenceFinder::basisLines.maps[lrank].end()) {										if (lk != ll) {											if (ReferenceFinder::basisLines.TotalSize() >= 												ReferenceFinder::maxLines) return;											RefLine_P2L_P2L rlp0(mi->second, lk->second, 												mj->second, ll->second, 0);											ReferenceFinder::basisLines.AddCopyIfValidAndUnique(												rlp0);											if (ReferenceFinder::basisLines.TotalSize() >= 												ReferenceFinder::maxLines) return;											RefLine_P2L_P2L rlp1(mi->second, lk->second, 												mj->second, ll->second, 1);											ReferenceFinder::basisLines.AddCopyIfValidAndUnique(												rlp1);											if (ReferenceFinder::basisLines.TotalSize() >= 												ReferenceFinder::maxLines) return;											RefLine_P2L_P2L rlp2(mi->second, lk->second, 												mj->second, ll->second, 2);											ReferenceFinder::basisLines.AddCopyIfValidAndUnique(												rlp2);										};										ll++;									};									lk++;								};								mj++;							};							mi++;						}					}				}}/************	RefLine_L2L_P2L - Huzita-Hatori Axiom O7 (Hatori's Axiom).**	Bring line l1 onto itself so that point p1 falls on line l2.***********//*******	RefLine_L2L_P2L::RefLine_L2L_P2L(RefLine* arl1, RefMark* arm1, RefLine* arl2) - *	Constructor. iroot can be 0 or 1.******/RefLine_L2L_P2L::RefLine_L2L_P2L(RefLine* arl1, RefMark* arm1, RefLine* arl2) :	RefLine(CalcLineRank(arl1, arm1, arl2)), rl1(arl1), rm1(arm1), rl2(arl2){	// Get references		XYLine& l1 = rl1->l;	XYPt& u1 = l1.u;	double& d1 = l1.d;	XYPt& p1 = rm1->p;	XYLine& l2 = rl2->l;	XYPt& u2 = l2.u;//	double& d2 = l2.d;		// Construct direction vector and distance scalar		l.u = u2.Rotate90();		double uf1 = l.u.Dot(u1);		if (abs(uf1) < EPS) return;	// parallel lines, no solution		l.d = (d1 + 2 * p1.Dot(l.u) * uf1 - p1.Dot(u1)) / (2 * uf1);		// Make sure point of intersection of fold with l2 lies within the paper.		XYPt pt = Intersection(l, l2);	if (!RefBase::paper.Encloses(pt)) return;		// Make sure point of incidence of p1 on l1 lies within the paper.		XYPt p1p = l.Fold(p1);	if (!RefBase::paper.Encloses(p1p)) return;		// Make sure p1 isn't already on l1 (in which case the alignment is ill-defined).		if (l1.Intersects(p1)) return;		// Check visibility.		bool p1edge = arm1->IsOnEdge();	bool l1edge = arl1->IsOnEdge();		if (ReferenceFinder::visibilityMatters) {		XYPt lp1, lp2;		RefBase::paper.ClipLine(l, lp1, lp2);		double t1 = (lp1 - pt).Dot(l.u);		double t2 = (lp2 - pt).Dot(l.u);		double tp = (p1 - pt).Dot(l.u);		if ((t1 * tp) < 0) {			double ti = t2;			t2 = t1;			t1 = ti;		};	// now t1 is the parameter for the endpoint on the p1 side of l2.		if (p1edge && (abs(t1) <= abs(t2))) whoMoves = p1Moves;		else if (l1edge && (abs(t1) >= abs(t2))) whoMoves = l1Moves;		else return;	}	else {		whoMoves = p1Moves;	};			// If this line creates a skinny flap, we won't use it.		if (RefBase::paper.MakesSkinnyFlap(l)) return;			// Set the key.		FinishConstructor();}/*******	RefLine_L2L_P2L::UsesImmediate(RefBase* rb) - return true if this line uses rb for *	immediate reference.******/const bool RefLine_L2L_P2L::UsesImmediate(RefBase* rb) const{	return (rb == rl1 || rb == rm1 || rb == rl2);}/*******	RefLine_L2L_P2L::SequencePushSelf() - Build the folding sequence*	that constructs this object.******/void RefLine_L2L_P2L::SequencePushSelf(){	switch (whoMoves) {		case p1Moves:			rl1->SequencePushSelf();			rm1->SequencePushSelf();			break;		case l1Moves:			rm1->SequencePushSelf();			rl1->SequencePushSelf();			break;	};	rl2->SequencePushSelf(); 	RefBase::SequencePushSelf();}			/*******	RefLine_L2L_P2L::PutHowto(ostream& os) - Put the name of this line to a stream.******/const bool RefLine_L2L_P2L::PutHowto(ostream& os) const{	if (axiomsInVerbalDirections) os << "[07] ";	os << "Bring ";	rl2->PutName(os);	os << " onto itself so that ";	switch (whoMoves) {		case p1Moves:			rm1->PutName(os);			os << " touches ";			rl1->PutName(os);			break;				case l1Moves:			rl1->PutName(os);			os << " touches ";			rm1->PutName(os);			break;	};	os << ", making ";	PutName(os);	return true;}/*******	RefLine_L2L_P2L::DrawSelf(RefStyle rstyle, short ipass) - Draw this line, *	adding arrows if appropriate******/void RefLine_L2L_P2L::DrawSelf(RefStyle rstyle, short ipass) const{	// Call inherited method to draw the lines		RefLine::DrawSelf(rstyle, ipass);		// If we're moving, we need an arrow		if ((ipass == arrowPass) && (rstyle == actionRef)) {					// Draw line-to-itself arrow				XYPt p1, p2;		XYLine& l2 = rl2->l;		RefBase::paper.ClipLine(l2, p1, p2);	// get endpts of the reference line		XYPt pi = Intersection(l, l2);					// intersection w/ fold line		XYPt u1p = l2.u.Rotate90();						// tangent to reference line		double t1 = abs((p1 - pi).Dot(u1p));		double t2 = abs((p2 - pi).Dot(u1p));		double tmin = t1 < t2 ? t1 : t2;		mDgmr->DrawFoldAndUnfoldArrow(pi + tmin * u1p, pi - tmin * u1p);				// Draw point-to-line arrow				XYPt& p3 = rm1->p;		XYPt p3p = l.Fold(p3);		switch(whoMoves) {			case p1Moves:				mDgmr->DrawFoldAndUnfoldArrow(p3, p3p);				break;			case l1Moves:				mDgmr->DrawFoldAndUnfoldArrow(p3p, p3);				break;		}	}}/*******	RefLine_L2L_P2L::MakeAll(rank_t arank) - Go*	through existing lines and marks and create RefLine_L2L_P2Ls with rank equal arank*	up to a cumulative total of maxLines.******/void RefLine_L2L_P2L::MakeAll(rank_t arank){	for (rank_t irank = 0; irank <= (arank - 1); irank++)		for (rank_t jrank = 0; jrank <= (arank - 1 - irank); jrank++) {			rank_t krank = arank - irank - jrank - 1;			RefContainer<RefLine>::rank_iterator li = 				ReferenceFinder::basisLines.maps[irank].begin();			while (li != ReferenceFinder::basisLines.maps[irank].end()) {				RefContainer<RefMark>::rank_iterator mj = 					ReferenceFinder::basisMarks.maps[jrank].begin();				while (mj != ReferenceFinder::basisMarks.maps[jrank].end()) {					RefContainer<RefLine>::rank_iterator lk = 						ReferenceFinder::basisLines.maps[krank].begin();					while (lk != ReferenceFinder::basisLines.maps[krank].end()) {						if (li != lk) {							if (ReferenceFinder::basisLines.TotalSize() >= 								ReferenceFinder::maxLines) return;							RefLine_L2L_P2L rlh1(li->second, mj->second, lk->second);							ReferenceFinder::basisLines.AddCopyIfValidAndUnique(rlh1);						};						lk++;					};					mj++;				};				li++;			}		}}/********************************************************************************	Section 3: containers for collections of marks and lines**	These containers are templated on the object type; we use the same type for both*	RefMarks and RefLines.*******************************************************************************//************	RefContainer - a container for storing RefMark* and RefLine* that*	organizes them by rank and within a rank, uses a map<R*> to store them. The mKey*	member variable is used as the key in the map; only one object is stored per key.*	class R = RefMark or RefLine***********//*******	RefContainer<R>::RefContainer() - Constructor. Initialize arrays.******/template <class R>RefContainer<R>::RefContainer() : rcsz(0), rcbz(0){	// expand our map array to hold all the ranks that we will create		maps.resize(1 + ReferenceFinder::maxRank);}/*******	RefContainer<R>::TotalSize() - return the total size of the container, including*	all ranks and the buffer.******/template <class R>size_t RefContainer<R>::TotalSize() const{	return rcsz + rcbz;}/*******	RefContainer<R>::AddCopyIfValidAndUnique(Rs& ars) - Check the validity and uniqueness*	of object ars of type Rs (descended from type R), and if it passes, add it to the container.*	Used by all the MakeAll() functions. Note that we use the default (compiler-generated)*	copy constructor, which is OK since our objects only contain POD, pointers that we WANT*	blind-copied, and/or strings (which know how to copy themselves).******/template <class R>template <class Rs>void RefContainer<R>::AddCopyIfValidAndUnique(const Rs& ars){	// The ref is valid (fully constructed) if its key is something other than 0.	// It's unique if the container doesn't already have one with the same key in one of	// the rank maps.		if (ars.mKey != 0 && !Contains(&ars)) Add(new Rs(ars));	ReferenceFinder::OccasionalShowProgress();	// report progress if appropriate}/*******	RefContainer<R>::Reinitialize() - Reinitialize all arrays and related counters.******/template <class R>void RefContainer<R>::Reinitialize(){	rcsz = 0;	rcbz = 0;	resize(0);	maps.resize(0);	maps.resize(1 + ReferenceFinder::maxRank);}/*******	RefContainer<R>::Contains(R* ar) - return true if the container (or the buffer)*	contain an equivalent object.******/template <class R>bool RefContainer<R>::Contains(const R* ar) const{	// go through each rank and look for an object with the same key. If we find one,	// return true.	for (size_t ir = 0; ir < maps.size(); ir++) if (maps[ir].count(ar->mKey)) return true;		// Also check the buffer.		if (buffer.count(ar->mKey)) return true;		// Still here? then we didn't find it.		return false;}/*******	RefContainer<R>::Add(R* ar) - Add an element to the array; to be called only if an equivalent*	element isn't already present anywhere. To avoid corrupting iterators, we add the new*	element to the buffer; it will get added to the main container on the next call to*	FlushBuffer().******/template<class R>void RefContainer<R>::Add(R* ar){	// Add it to the buffer and increment the buffer size.		buffer.insert(map_t::value_type(ar->mKey, ar));	rcbz++;}/*******	RefContainer<R>::FlushBuffer() - put the contents of the buffer into the main container.******/template <class R>void RefContainer<R>::FlushBuffer(){	// Make room for the buffer in the sortable list.		reserve(size() + rcbz);		// Go through the buffer and add each element to the appropriate rank in the main container.		rank_iterator bi = buffer.begin();	while (bi != buffer.end()) {		R*& rr = bi->second;				// get pointer to each new element		maps[rr->mRank].insert(*bi);		// add to the map of the appropriate rank		push_back(rr);						// also add to our sortable list		rcsz++;								// increment our size counter		bi++;								// increment the buffer iterator	};	buffer.clear();							// clear the buffer	rcbz = 0;}/*******	RefContainer<R>::ClearMaps() - clear the map arrays. Called when they're no longer needed.******/template <class R>void RefContainer<R>::ClearMaps(){	for (size_t ir = 0; ir < maps.size(); ir++) maps[ir].clear();}/********************************************************************************	Section 4: routines for building sets of marks and lines and collecting statistics*******************************************************************************//************	CompareError - function object for comparing two refs of class R according to their *	distance from a target value of class X.***********//*******	CompareError<R>::operator()(R* r1, R* r2) - return true if rl1 is*	a better R than rl2. Comparison is strictly on distance, with ties resolved by rank.******/template <class R>bool CompareError<R>::operator()(R* r1, R* r2) const{	// Compare the distances from the stored R::bare_t. If the distances are equal,	// then compare the marks by their rank.		double d1 = r1->Distance(b);	double d2 = r2->Distance(b);		if (d1 == d2) return r1->mRank < r2->mRank;		else return d1 < d2;}/************	CompareRankAndError - function object for comparing two refs of class R according to their *	distance from a target value of class X, but for close points, letting rank win out***********//*******	CompareRankAndError<R>::operator()(R* r1, R* r2) - return true if r1 is*	a better R than r2. **	If either mark is farther than maxError, return true if r1 is closer than r2.*	If both are within maxError, then return true if r1 has a lower rank than r2.*	If both are within maxError and they have the same rank, then return true if r1 is closer.******/template <class R>bool CompareRankAndError<R>::operator()(R* r1, R* r2) const{	// Compare the distances from the given point. If both distances are less than or equal to maxError,	// compare the marks by their rank.		double d1 = r1->Distance(b);	double d2 = r2->Distance(b);			if ((d1 > ReferenceFinder::maxError) || (d2 > ReferenceFinder::maxError)) {		if (d1 == d2) return r1->mRank < r2->mRank;			else return d1 < d2;	}	else {		if (r1->mRank == r2->mRank) return d1 < d2;		else return r1->mRank < r2->mRank;	}}/************	ReferenceFinder - object that builds and maintains collections of marks and lines and*	can search throught the collection for marks and lines close to a target mark or line.***********//*******	ReferenceFinder static member initialization******/RefContainer<RefLine> ReferenceFinder::basisLines;RefContainer<RefMark> ReferenceFinder::basisMarks;void *ReferenceFinder::pShowProgressData = 0;ReferenceFinder::ProgressFn ReferenceFinder::pShowProgress = &ConsoleShowProgress;int ReferenceFinder::numTries;/*******	ReferenceFinder::SetShowProgress(ProgressFn apfn) - install a ProgressFn to use as *	the callback routine, overriding the default method which sends progress to the console.******/void ReferenceFinder::SetShowProgress(ProgressFn apfn, void *d){	pShowProgress = apfn;	pShowProgressData = d;}/*******	ReferenceFinder::ConsoleShowProgress(ProgressMsg pmsg, rank_t arank) - Show progress by*	reporting information to the console. Clients can install their own version of this*	function by calling ReferenceFinder::SetShowProgress(..).******/void ReferenceFinder::ConsoleShowProgress(ProgressMsg pmsg, rank_t arank, void*){#ifndef NO_CONSOLE	switch (pmsg) {		case msgInitializing:	// Called at beginning of initialization			cout << "Initializing using";			if (RefLine_C2P_C2P::include) cout << " O1,";			if (RefLine_P2P::include) cout << " O2,";			if (RefLine_L2L::include) cout << " O3,";			if (RefLine_L2L_C2P::include) cout << " O4,";			if (RefLine_P2L_C2P::include) cout << " O5,";			if (RefLine_P2L_P2L::include) cout << " O6,";			if (RefLine_L2L_P2L::include) cout << " O7,";			cout << " vis=";			if (visibilityMatters) cout << "true";			else cout << "false";			cout << flush;				break;					case msgWorking:		// Called while we're building lines and marks			cout << "." << flush;			break;				case msgRankCompleted:	// Called when we've finished a rank			cout << endl << "There are " << basisLines.TotalSize() << " lines and " << 				basisMarks.TotalSize() << " marks of rank <= " << arank << " " << flush;			break;				case msgInitialized:	// Called when we're completely done			// default doesn't do much, but clients might do something			cout << endl << endl << flush;			break;	}#endif}/*******	ReferenceFinder::OccasionalShowProgress() - routine called by RefContainer<R> to display *	progress during the time-consuming process of initialization. This routine updates its *	private counter each time it's called and only occasionally passes on a full call to *	pShowProgress. Clients can adjust the frequency of calling by changing the variable*	maxTries.******/void ReferenceFinder::OccasionalShowProgress(){	if (numTries < maxTries) numTries++;	else {		(*pShowProgress)(msgWorking, 0, pShowProgressData);		numTries = 0;	}}/*******	ReferenceFinder::MakeAllMarksAndLinesOfRank(rank_t arank) - create all marks and lines *	of a given rank.******/void ReferenceFinder::MakeAllMarksAndLinesOfRank(rank_t arank){	// construct all types of lines of the given rank. Note that the order in which we call	// the MakeAll() functions determines which types of RefLine get built, since the first	// object with a given key to be constructed gets the key slot.		// We give first preference to lines that don't involve making creases through	// points, because these are the hardest to do accurately in practice.		if (RefLine_L2L::include) RefLine_L2L::MakeAll(arank);	if (RefLine_P2P::include) RefLine_P2P::MakeAll(arank);	if (RefLine_L2L_P2L::include) RefLine_L2L_P2L::MakeAll(arank);	if (RefLine_P2L_P2L::include) RefLine_P2L_P2L::MakeAll(arank);		// Next, we'll make lines that put a crease through a single point.		if (RefLine_P2L_C2P::include) RefLine_P2L_C2P::MakeAll(arank);	if (RefLine_L2L_C2P::include) RefLine_L2L_C2P::MakeAll(arank);			// Finally, we'll do lines that put a crease through both points.			if (RefLine_C2P_C2P::include) RefLine_C2P_C2P::MakeAll(arank);				// Having constructed all lines in the buffer, add them to the main collection.		basisLines.FlushBuffer();		// construct all types of marks of the given rank		RefMark_Intersection::MakeAll(arank);		basisMarks.FlushBuffer();		// if we're reporting status, say how many we constructed.		(*pShowProgress)(msgRankCompleted, arank, pShowProgressData);}/*******	ReferenceFinder::MakeAllMarksAndLines() - create all marks and lines sequentially.******/void ReferenceFinder::MakeAllMarksAndLines(){	// Start by clearing out any old marks or lines; this is so we can restart if	// we want.		basisLines.Reinitialize();	basisMarks.Reinitialize();		// First thing we do is a range check on the key quantization. There should be some	// way to do this to generate a compile-time error rather than a run-time error, but	// I haven't figured out a good way to do it.		if (!RefMark::KeySizeOK() || !RefLine::KeySizeOK()) {#ifndef NO_CONSOLE		cout << "Sorry, RefBase::key_t isn't big enough to hold all key values.\n";		cout << "Please redefine key_t to a larger type and recompile the program.\n";#endif		exit(1);	};		// Let the user know that we're initializing and what operations we're using.		(*pShowProgress)(msgInitializing, 0, pShowProgressData);		// Build a bunch of marks of successively higher rank. Note that building lines	// up to rank 4 and marks up to rank 8 with no limits would result in 4185 lines and	// 1,090,203 marks, which would take about 60 MB of memory.		// Rank 0: Construct the four edges of the square.	basisLines.Add(new RefLine_Original(RefBase::paper.bottomEdge, 0, 		string("the bottom edge")));	basisLines.Add(new RefLine_Original(RefBase::paper.leftEdge, 0, 		string("the left edge")));	basisLines.Add(new RefLine_Original(RefBase::paper.rightEdge, 0, 		string("the right edge")));	basisLines.Add(new RefLine_Original(RefBase::paper.topEdge, 0, 		string("the top edge")));			// Rank 0: Construct the four corners of the square.		basisMarks.Add(new RefMark_Original(RefBase::paper.botLeft, 0, 		string("the bottom left corner")));	basisMarks.Add(new RefMark_Original(RefBase::paper.botRight, 0, 		string("the bottom right corner")));	basisMarks.Add(new RefMark_Original(RefBase::paper.topLeft, 0, 		string("the top left corner")));	basisMarks.Add(new RefMark_Original(RefBase::paper.topRight, 0, 		string("the top right corner")));			// Report our status for rank 0.		(*pShowProgress)(msgRankCompleted, 0, pShowProgressData);		// Rank 1: Construct the two diagonals.	basisLines.Add(new RefLine_Original(RefBase::paper.upwardDiagonal, 1, 		string("the upward diagonal")));	basisLines.Add(new RefLine_Original(RefBase::paper.downwardDiagonal, 1, 		string("the downward diagonal")));			// Flush the buffers.		basisLines.FlushBuffer();	basisMarks.FlushBuffer();	// Now build the rest, one rank at a time, starting with rank 1.		for (rank_t irank = 1; irank <= maxRank; irank++) {		MakeAllMarksAndLinesOfRank(irank);	};	// Once that's done, all the objects are in the sortable arrays and we can free up the	// memory used by the maps.		basisLines.ClearMaps();	basisMarks.ClearMaps();		(*pShowProgress)(msgInitialized, 0, pShowProgressData);}/*******	ReferenceFinder::MesserCubeRoot() - this routine builds Peter Messer's construction of *	cube root of 2.	Only used for testing, but I'll leave it in here for edification.******/void ReferenceFinder::MesserCubeRoot(){	// Rank 0: Construct the four edges of the square.	RefLine *be, *le, *re, *te;		ReferenceFinder::basisLines.Add(be = new RefLine_Original(		RefBase::paper.bottomEdge, 0, string("bottom edge")));	ReferenceFinder::basisLines.Add(le = new RefLine_Original(		RefBase::paper.leftEdge, 0, string("left edge")));	ReferenceFinder::basisLines.Add(re = new RefLine_Original(		RefBase::paper.rightEdge, 0, string("right edge")));	ReferenceFinder::basisLines.Add(te = new RefLine_Original		(RefBase::paper.topEdge, 0, string("top edge")));	// Rank 0: Construct the four corners of the square.		RefMark *blc, *brc, *tlc, *trc;		ReferenceFinder::basisMarks.Add(blc = new RefMark_Original(	RefBase::paper.botLeft, 0, string("bot left corner")));	ReferenceFinder::basisMarks.Add(brc = new RefMark_Original(	RefBase::paper.botRight, 0, string("bot right corner")));	ReferenceFinder::basisMarks.Add(tlc = new RefMark_Original(	RefBase::paper.topLeft, 0, string("top left corner")));	ReferenceFinder::basisMarks.Add(trc = new RefMark_Original(	RefBase::paper.topRight, 0, string("top right corner")));	// Create the endpoints of the two initial fold lines		RefMark *rma1, *rma2, *rmb1, *rmb2;		ReferenceFinder::basisMarks.Add(rma1 = new RefMark_Original(XYPt(0, 1./3), 0, 		string("(0, 1/3)")));	ReferenceFinder::basisMarks.Add(rma2 = new RefMark_Original(XYPt(1, 1./3), 0, 		string("(1, 1/3)")));	ReferenceFinder::basisMarks.Add(rmb1 = new RefMark_Original(XYPt(0, 2./3), 0, 		string("(0, 2/3)")));	ReferenceFinder::basisMarks.Add(rmb2 = new RefMark_Original(XYPt(1, 2./3), 0, 		string("(1, 2/3)")));	// Create and add the two initial fold lines.		RefLine *rla, *rlb;		ReferenceFinder::basisLines.Add(rla = new RefLine_C2P_C2P(rma1, rma2));	ReferenceFinder::basisLines.Add(rlb = new RefLine_C2P_C2P(rmb1, rmb2));		// Construct the fold line		RefLine_P2L_P2L rlc(brc, le, rma2, rlb, 0);		// Print the entire sequence	#ifndef NO_CONSOLE	rlc.PutHowtoSequence(cout);#endif		// quit the program		exit(1);}/*******	ReferenceFinder::FindBestMarks(const XYPt& ap, vector<RefMark*>& vm, short numMarks) -- *	Find the best marks closest to a given point ap, storing the results in the vector vm.******/void ReferenceFinder::FindBestMarks(const XYPt& ap, vector<RefMark*>& vm, short numMarks){	vm.resize(numMarks);	partial_sort_copy(basisMarks.begin(), basisMarks.end(), vm.begin(), vm.end(), 		CompareRankAndError<RefMark>(ap));}/*******	ReferenceFinder::FindBestLines(const XYLine& al, vector<RefLine*>& vl, short numLines) -- *	Find the best lines closest to a given line al, storing the results in the vector vl.******/void ReferenceFinder::FindBestLines(const XYLine& al, vector<RefLine*>& vl, short numLines){	vl.resize(numLines);	partial_sort_copy(basisLines.begin(), basisLines.end(), vl.begin(), vl.end(), 		CompareRankAndError<RefLine>(al));}/*******	ReferenceFinder::ValidateMark(XYPt ap) - return true if ap is a valid mark. *	Print an error message if it isn't.******/bool ReferenceFinder::ValidateMark(const XYPt& ap){	if (ap.x < 0 || ap.x > RefBase::paper.pWidth) {#ifndef NO_CONSOLE		cout << endl << "Error -- x coordinate should lie between 0 and " << 			RefBase::paper.pWidth << endl;#endif		return false;	}		if (ap.y < 0 || ap.y > RefBase::paper.pHeight) {#ifndef NO_CONSOLE		cout << endl << "Error -- y coordinate should lie between 0 and " << 			RefBase::paper.pHeight << endl;#endif		return false;	}	return true;}/*******	ReferenceFinder::ValidateLine(XYPt ap1, XYPt ap2) - validate the two entered points *	that define the line. Print an error message if they aren't distinct.******/bool ReferenceFinder::ValidateLine(const XYPt& ap1, const XYPt& ap2){	if ((ap1 - ap2).Mag() > EPS) return true;#ifndef NO_CONSOLE	cout.precision(10);	cout << endl << "Error -- the two points must be distinct (separated by at least " <<		EPS << ")." << endl;#endif	return false;}/*******	void ReferenceFinder::CalcStatistics() - compute statistics on the accuracy of the *	current set of marks for a randomly chosen set of points.******/void ReferenceFinder::CalcStatistics(){#ifndef NO_CONSOLE	const short numBuckets = 11;		// We'll sort errors in buckets of width .001.	int errBucket[numBuckets];			// array of the number of errors in each bucket	for (short i = 0; i < numBuckets; i++) errBucket[i] = 0;	// initialize the array		const int numTries = 1000;		// number of test cases	vector<double> errors(numTries);	// a record of all errors		vector <RefMark*> sortMarks(1);	// a vector to do our sorting into		// Run a bunch of test cases.				cout.precision(4);		cout.setf(ios_base::fixed, ios_base::floatfield);		cout << "(test #) error" << endl;		for (int i = 0; i < numTries; i++) {		// Pick a random coordinate		XYPt testPt((double(rand()) / (RAND_MAX * RefBase::paper.pWidth)), 			double(rand()) / (RAND_MAX * RefBase::paper.pHeight));				// Find the mark closest to the test mark.		partial_sort_copy(basisMarks.begin(), basisMarks.end(), 			sortMarks.begin(), sortMarks.end(), CompareError<RefMark>(testPt));					// note how close we were and print the error, 5 to a line		errors[i] = (testPt - sortMarks[0]->p).Mag();		cout << "(" << i + 1 << "/" << numTries << ") " << errors[i] << ", ";		if (fmod((double)i + 1, 5) == 0) cout << endl;				// also, compute a bucket index for this error		int errindex = int(errors[i] / .001);				// over the top goes into last bucket		if (errindex >= numBuckets) errindex = numBuckets - 1;				// record the error into the appropriate bucket				errBucket[errindex] += 1;	}		// Now print the distribution of errors		cout.precision(1);	cout << endl << "Distribution of errors:" << endl;	int cum = 0;	for (int i = 0; i < numBuckets -1; i++) {		cum += errBucket[i];		cout << "error < " << .001 * (i + 1) << " = " << cum << 			"(" << 100. * double(cum) / numTries << "%)" << endl;	}	cout << "error > 0.01 = " << numTries - cum <<		"(" << 100. * double(numTries - cum) / numTries << "%)" << endl;			// sort the errors and print percentiles of the errors		sort(errors.begin(), errors.end());	cout.precision(4);	cout << endl << "Distribution of errors:" << endl;	cout << "10th percentile :" << errors[int(.10 * numTries)] << endl;	cout << "20th percentile :" << errors[int(.20 * numTries)] << endl;	cout << "50th percentile :" << errors[int(.50 * numTries)] << endl;	cout << "80th percentile :" << errors[int(.80 * numTries)] << endl;	cout << "90th percentile :" << errors[int(.90 * numTries)] << endl;	cout << "95th percentile :" << errors[int(.95 * numTries)] << endl;	cout << "99th percentile :" << errors[int(.99 * numTries)] << endl;	cout << endl;#endif}/********************************************************************************	Section 5: Routines for drawing diagrams*******************************************************************************//************	RefDgmr - object that draws folding diagrams of references. Subclasses specialize*	to particular drawing environments (print vs screen, multiple GUIs, platform-specific*	drawing models, etc.***********//*	Notes on RefDgmr and its descendants.	Subclasses will typically maintain an internal graphics state that describes the location	of the diagram on the canvas and will implement the handful of virtual drawing methods	that render the diagram on the canvas. The base class does nothing. All points are given	in the paper coordinate system. The subclass implementation of drawing should determine	the layout of the diagrams and offset and scale appropriately to convert to canvas	coordinates. See PSFileDgmr for an example.*/	/*******	RefDgmr::DrawPt(const XYPt& aPt, PointStyle pstyle) - *	draw a point in the given style.******/void RefDgmr::DrawPt(const XYPt& /* aPt */, PointStyle /* pstyle */){}/*******	RefDgmr::DrawLine(const XYPt& fromPt, const XYPt& toPt, LineStyle lstyle) - *	draw a line in the given style.******/void RefDgmr::DrawLine(const XYPt& /* fromPt */, const XYPt& /* toPt */, LineStyle /* lstyle */){}/*******	RefDgmr::DrawArc(const XYPt& ctr, const double rad, const double fromAngle,*	const double toAngle, LineStyle lstyle) - draw an arc in the given style.*	fromAngle and toAngle are given in radians.******/void RefDgmr::DrawArc(const XYPt& /* ctr */, const double /* rad */, const double /* fromAngle */,	const double /* toAngle */, const bool /* ccw */, LineStyle /* lstyle */){}/*******	RefDgmr::DrawPoly(const vector<XYPt>& poly, PolyStyle pstyle) -*	draw a polygon in the given style.******/void RefDgmr::DrawPoly(const vector<XYPt>& /* poly */, PolyStyle /* pstyle */){}/*******	RefDgmr::DrawLabel(const XYPt& aPt, const string& aString, LabelStyle lstyle) -*	draw a label at a given point******/void RefDgmr::DrawLabel(const XYPt& /* aPt */, const string& /* aString */, 	LabelStyle /* lstyle */){}/*	Class RefDgmr provides a set of routines for drawing arrows that are built on top of	the primitive routines above. These can be overridden if you want to implement a different	style of arrow.*//*******	RefDgmr::DrawValleyArrowhead(const XYPt& loc, const XYPt& dir, const double len) -*	Draw a valley-fold arrowhead with tip at location loc, direction dir, and size len.******/void RefDgmr::DrawValleyArrowhead(const XYPt& loc, const XYPt& dir, const double len){	DrawLine(loc, loc - len * dir.RotateCCW(.523), arrowLine);	DrawLine(loc, loc - len * dir.RotateCCW(-.523), arrowLine);}/*******	RefDgmr::DrawMountainArrowhead(const XYPt& loc, const XYPt& dir, const double len) -*	Draw a mountain arrowhead with tip at location loc, direction dir, and size len.******/void RefDgmr::DrawMountainArrowhead(const XYPt& loc, const XYPt& dir, const double len){	XYPt ldir = len * dir;	vector<XYPt> poly;	poly.push_back(loc);	poly.push_back(loc - ldir.RotateCCW(.523));	poly.push_back(loc - .8 * ldir);	DrawPoly(poly, arrowPoly);}/*******	RefDgmr::DrawUnfoldArrowhead(const XYPt& loc, const XYPt& dir, const double len) -*	Draw an unfold arrowhead with tip at location loc, direction dir, and size len.******/void RefDgmr::DrawUnfoldArrowhead(const XYPt& loc, const XYPt& dir, const double len){	XYPt ldir = len * dir;	vector<XYPt> poly;	poly.push_back(loc);	poly.push_back(loc - ldir.RotateCCW(.523));	poly.push_back(loc - .8 * ldir);	poly.push_back(loc - ldir.RotateCCW(-.523));	DrawPoly(poly, arrowPoly);}/*******	CalcArrow(const XYPt& fromPt, const XYPt& toPt,*	XYPt& ctr, double& rad, double& fromAngle, double& toAngle, bool& ccw,*	XYPt& fromDir, XYPt& toDir) - calculate all the parameters necessary to draw*	any type of arrow (valley, mountain, unfold, fold-and-unfold).******/void RefDgmr::CalcArrow(const XYPt& fromPt, const XYPt& toPt,	XYPt& ctr, double& rad, double& fromAngle, double& toAngle, bool& ccw,	double& ahSize, XYPt& fromDir, XYPt& toDir){	const double RADIANS = 57.29577951;	const double TWO_PI = 6.283185308;	const double PI = 3.1415926535;		const double ha = 30 / RADIANS;			// half-angle of arc of arrow, in degrees	const double tana = tan(ha);			// tan of this angle		XYPt mp = MidPoint(fromPt, toPt);		// midpoint of arrow line	XYPt mu = (toPt - fromPt);				// vector in direction of arrow line	XYPt mup = 0.5 * mu.Rotate90() / tana;	// vector from midpt to center of curvature		// Compute the center of rotation. There are two possible choices.	// We'll want the bulge of the arc to always be toward the inside of the square,	// i.e., closer to the middle of the square, so we pick the value of the center	// that's farther away.		XYPt sqmp = MidPoint(RefBase::paper.botLeft, RefBase::paper.topRight);	XYPt ctr1 = mp + mup;	XYPt ctr2 = mp - mup;	ctr = (ctr1 - sqmp).Mag() > (ctr2 - sqmp).Mag() ? ctr1 : ctr2;	// radius of the arc.	rad = (toPt - ctr).Mag();		// Now compute the angles of the lines to the two points.		XYPt fp = fromPt - ctr;	fromAngle = atan2(fp.y, fp.x);	XYPt tp = toPt - ctr;	toAngle = atan2(tp.y, tp.x);		// Check direction of rotation.		double ra = toAngle - fromAngle;	// rotation angle	while (ra < 0) ra += TWO_PI;		// get it into the right range	while (ra > TWO_PI) ra -= TWO_PI;		ccw = (ra < PI);					// true == arc goes in ccw direction		// Compute the size of the arrowheads		ahSize = RefBase::paper.pWidth;	if (ahSize > RefBase::paper.pHeight) ahSize = RefBase::paper.pHeight;	ahSize *= 0.15;	double ah1 = 0.4 * (toPt - fromPt).Mag();	if (ahSize > ah1) ahSize = ah1;		// Compute the direction vectors for the arrowheads		mu.NormalizeSelf();	toDir = ccw ? mu.RotateCCW(ha) : mu.RotateCCW(-ha);	mu *= -1;	fromDir = ccw ? mu.RotateCCW(-ha) : mu.RotateCCW(ha);}/*******	RefDgmr::DrawValleyArrow(XYPt& fromPt, XYPt& toPt) - draw a valley-fold*	arrows. fromPt is the moving point, toPt is the destination.******/void RefDgmr::DrawValleyArrow(const XYPt& fromPt, const XYPt& toPt){	XYPt ctr;	double rad;	double fromAngle;	double toAngle;	bool ccw;	double ahSize;	XYPt fromDir;	XYPt toDir;	CalcArrow(fromPt, toPt, ctr, rad, fromAngle, toAngle, ccw, ahSize, fromDir, toDir);	DrawArc(ctr, rad, fromAngle, toAngle, ccw, arrowLine);	DrawValleyArrowhead(toPt, toDir, ahSize);}/*******	RefDgmr::DrawMountainArrow(XYPt& fromPt, XYPt& toPt) - draw a mountain-fold*	arrows. fromPt is the moving point, toPt is the destination.******/void RefDgmr::DrawMountainArrow(const XYPt& fromPt, const XYPt& toPt){	XYPt ctr;	double rad;	double fromAngle;	double toAngle;	bool ccw;	double ahSize;	XYPt fromDir;	XYPt toDir;	CalcArrow(fromPt, toPt, ctr, rad, fromAngle, toAngle, ccw, ahSize, fromDir, toDir);	DrawArc(ctr, rad, fromAngle, toAngle, ccw, arrowLine);	DrawMountainArrowhead(toPt, toDir, ahSize);}/*******	RefDgmr::DrawUnfoldArrow(XYPt& fromPt, XYPt& toPt) - draw a unfold*	arrows. fromPt is the moving point, toPt is the destination.******/void RefDgmr::DrawUnfoldArrow(const XYPt& fromPt, const XYPt& toPt){	XYPt ctr;	double rad;	double fromAngle;	double toAngle;	bool ccw;	double ahSize;	XYPt fromDir;	XYPt toDir;	CalcArrow(fromPt, toPt, ctr, rad, fromAngle, toAngle, ccw, ahSize, fromDir, toDir);	DrawArc(ctr, rad, fromAngle, toAngle, ccw, arrowLine);	DrawUnfoldArrowhead(toPt, toDir, ahSize);}/*******	RefDgmr::DrawFoldAndUnfoldArrow(XYPt& fromPt, XYPt& toPt) - draw a fold-and-unfold*	arrows. fromPt is the moving point, toPt is the destination.******/void RefDgmr::DrawFoldAndUnfoldArrow(const XYPt& fromPt, const XYPt& toPt){	XYPt ctr;	double rad;	double fromAngle;	double toAngle;	bool ccw;	double ahSize;	XYPt fromDir;	XYPt toDir;	CalcArrow(fromPt, toPt, ctr, rad, fromAngle, toAngle, ccw, ahSize, fromDir, toDir);	DrawArc(ctr, rad, fromAngle, toAngle, ccw, arrowLine);	DrawValleyArrowhead(toPt, toDir, ahSize);	DrawUnfoldArrowhead(fromPt, fromDir, ahSize);}/************	class ConsoleTextDgmr - a minimal subclass of RefDgmr that puts verbal-only descriptions*	to the console.***********//*******	ConsoleTextDgmr::PutRefList(const R::bare_t& ar, vector<R*>& vr) - Write a list of *	references to the console, along with their error and how-to description. *	This template function is used in the mark- and line-specific routines that follow.******/template <class R>void ConsoleTextDgmr::PutRefList(const typename R::bare_t& ar, vector<R*>& vr){	RefBase::SetClarifyVerbalAmbiguities(true);	// resolve all ambiguities with extra info	RefBase::SetAxiomsInVerbalDirections(true);	// list the axioms with each alignment		// Print out the distance error, rank, and instructions for each ref.		cout << endl;	for (size_t i = 0; i < vr.size(); i++) {		vr[i]->PutDistanceAndRank(cout, ar);		cout << endl;		vr[i]->PutHowtoSequence(cout);	};	cout << endl;}/*******	ConsoleTextDgmr::PutLineList(const XYLine& ll, vector<RefLine*>& vl) - *	write a list of lines to the console, including error and how-to description.******/void ConsoleTextDgmr::PutLineList(const XYLine& ll, vector<RefLine*>& vl){	PutRefList(ll, vl);}/*******	ConsoleTextDgmr::PutMarkList(const XYPt& pp, vector<RefMark*> vm) - *	write a list of marks to the console, including error and how-to description.******/void ConsoleTextDgmr::PutMarkList(const XYPt& pp, vector<RefMark*>& vm){	PutRefList(pp, vm);}/************	PSFileDgmr - a specialization of RefDgmr that writes a PostScript file of diagrams.***********//*******	PSFileDgmr static member initialization******/double PSFileDgmr::usize = 64;		// 72 pts = 1 inch, 1 unit = 64 pts, fits 7 dgmsXYPt PSFileDgmr::origin;								// just needs to be initializedconst XYRect PSFileDgmr::pageSize(40, 40, 572, 752);	// printable area on the pageint PSFileDgmr::fileNum = 0;							// counter for output filesstring PSFileDgmr::fileName;							// name of output file/*******	PSFileDgmr::PSPt::PSPt(const XYPt& aPt) - constructor for a PostScript point, which*	scales the XYPt and offsets its according to the static variables origin and usize.******/PSFileDgmr::PSPt::PSPt(const XYPt& aPt) : 	px(origin.x + usize * aPt.x), 	py(origin.y + usize * aPt.y){}/*******	operator<<(ostream& os, const PSPt& pp) - Stream output for a PostScript point******/ostream& operator<<(ostream& os, const PSFileDgmr::PSPt& pp){	return os << pp.px << " " << pp.py;}/*******	PSFileDgmr::SetPointStyle(PointStyle pstyle) - set the current graphics state to the*	given PointStyle.******/void PSFileDgmr::SetPointStyle(PointStyle pstyle){	switch (pstyle) {		case normalPt:			psfile << "1 setlinewidth 0 setgray " << endl;			break;		case hilitePt:			psfile << "3 setlinewidth .5 .25 .25 setrgbcolor " << endl;			break;		case actionPt:			psfile << "3 setlinewidth .5 0 0 setrgbcolor " << endl;			break;	}}/*******	PSFileDgmr::SetLineStyle(LineStyle lstyle) - set the current graphics state to the*	given LineStyle******/void PSFileDgmr::SetLineStyle(LineStyle lstyle){	switch (lstyle) {		case creaseLine:			psfile << "[] 0 setdash .20 setlinewidth 0 setgray " << endl;			break;		case edgeLine:			psfile << "[] 0 setdash .5 setlinewidth 0 setgray " << endl;			break;		case hiliteLine:			psfile << "[] 0 setdash 1 setlinewidth 1 .5 .5 setrgbcolor " << endl;			break;		case valleyLine:			psfile << "[4 3] 0 setdash .5 setlinewidth 1 0 0 setrgbcolor " << endl;			break;		case mountainLine:			psfile << "[3 3 0 3 0 3] 0 setdash .5 setlinewidth 1 0 0 setrgbcolor " << endl;			break;		case arrowLine:			psfile << "[] 0 setdash .4 setlinewidth 0 .5 0 setrgbcolor " << endl;			break;	}}/*******	PSFileDgmr::SetPolyStyle(PolyStyle pstyle) - set the current graphics state to the*	given PolyStyle******/void PSFileDgmr::SetPolyStyle(PolyStyle pstyle){	switch (pstyle) {		case whitePoly:			psfile << ".95 .95 1 setrgbcolor " << endl;			break;		case coloredPoly:			psfile << "0 0 .5 setrgbcolor " << endl;			break;		case arrowPoly:			psfile << ".95 1 .95 setrgbcolor " << endl;			break;	}}/*******	PSFileDgmr::SetLabelStyle(LabelStyle lstyle) - set the current graphics state to the*	given LabelStyle******/void PSFileDgmr::SetLabelStyle(LabelStyle lstyle){	switch (lstyle) {		case normalLabel:			psfile << "0 setgray " << endl;			break;		case hiliteLabel:			psfile << ".5 .25 .25 setrgbcolor " << endl;			break;		case actionLabel:			psfile << ".5 0 0 setrgbcolor " << endl;			break;	}}/*******	PSFileDgmr::DrawPt(const XYPt& aPt, PointStyle pstyle) - draw a PostScript*	point in the indicated style.******/void PSFileDgmr::DrawPt(const XYPt& aPt, PointStyle pstyle){	SetPointStyle(pstyle);	psfile << "newpath " << PSPt(aPt) << " moveto 0 0 rlineto stroke" << endl;}/*******	PSFileDgmr::DrawLine(const XYPt& fromPt, const XYPt& toPt, LineStyle lstyle) -*	Draw a PostScript line in the indicated style.******/void PSFileDgmr::DrawLine(const XYPt& fromPt, const XYPt& toPt, LineStyle lstyle){	SetLineStyle(lstyle);	psfile << "newpath " << PSPt(fromPt) << " moveto " << PSPt(toPt) << " lineto stroke" << endl;}/*******	PSFileDgmr::DrawArc(const XYPt& ctr, const double rad, const double fromAngle,	const double toAngle, LineStyle lstyle) - draw a PostScript arc in the indicated style.******/void PSFileDgmr::DrawArc(const XYPt& ctr, const double rad, const double fromAngle,	const double toAngle, bool ccw, LineStyle lstyle){	SetLineStyle(lstyle);	const double RADIANS = 57.29577951;	if (ccw)		psfile << "newpath " << PSPt(ctr) << " " << rad * usize << " " << 		fromAngle * RADIANS << " " << toAngle * RADIANS  << " arc stroke" << endl;	else		psfile << "newpath " << PSPt(ctr) << " " << rad * usize << " " << 		fromAngle * RADIANS  << " " << toAngle * RADIANS  << " arcn stroke" << endl;}/*******	PSFileDgmr::DrawPoly(const vector<XYPt>& poly, PolyStyle pstyle) -*	Fill and stroke the given poly in the indicated style.******/void PSFileDgmr::DrawPoly(const vector<XYPt>& poly, PolyStyle pstyle){	psfile << "newpath " << PSPt(poly[poly.size()-1]) << " moveto " << endl;	for (size_t i = 0; i < poly.size(); i++)		psfile << PSPt(poly[i]) << " lineto" << endl;	psfile << "gsave " << endl;	// Fill the poly		SetPolyStyle(pstyle);	psfile << "fill grestore " << endl;		// Stroke the poly		switch (pstyle) {		case whitePoly:		case coloredPoly:			SetLineStyle(edgeLine);			break;		case arrowPoly:			SetLineStyle(arrowLine);			break;	};	psfile << "stroke " << endl;}/*******	PSFileDgmr::DrawLabel(const XYPt& aPt, const string& aString, labelStyle lstyle) -*	Draw a text label at the point aPt in the indicated style******/void PSFileDgmr::DrawLabel(const XYPt& aPt, const string& aString, LabelStyle lstyle){	SetLabelStyle(lstyle);	psfile << PSPt(aPt) << " moveto (" << aString << ") show " << endl;}/*******	PSFileDgmr::DecrementOrigin(double d) - decrement the origin by a distance*	d. If we drop below the bottom margin, start a new page.******/void PSFileDgmr::DecrementOrigin(double d){	origin.y -= d;	if (origin.y >= pageSize.bl.y) return;	psfile << "showpage" << endl;	psfile << "%%Page: " << ++pageNum << " " << pageNum << endl;	origin.y = pageSize.tr.y - d;}	/*******	PSFileDgmr::PutRefList(const typename R::bare_t& ar, vector<R*>& vr) -*	Draw a set of marks or lines to a PostScript file, showing distance and rank for*	each sequence.******/template <class R>void PSFileDgmr::PutRefList(const typename R::bare_t& ar, vector<R*>& vr){	RefBase::SetClarifyVerbalAmbiguities(false);	// don't need extra info with diagrams	RefBase::SetAxiomsInVerbalDirections(false);	// don't need axiom numbers	// Open a file for output.	stringstream filestr;	filestr << "ReferenceFinder_" << setw(3) << setfill('0') << ++fileNum << ".ps";	fileName = filestr.str();	// note filename in static variable for future reference	psfile.open(fileName.c_str(), ios::out | ios::trunc);	if (!psfile.good()) {		cout << "error opening file" << endl;		return;	};		// Put some comments so our readers are happy		psfile << "%!PS-Adobe-1.0" << endl;	psfile << "%%Pages: (atend)" << endl;	psfile << "%%EndComments" << endl;	psfile << "%%Page: 1 1" << endl;		// Set the page number. DecrementOrigin will update it as needed	pageNum = 1;		// Put some initial setup information		psfile << "1 setlinecap" << endl;	psfile << "1 setlinejoin" << endl;		// Setup and draw a header.		origin.x = pageSize.bl.x;	origin.y = pageSize.tr.y;	psfile << "/Times-Roman findfont 12 scalefont setfont" << endl;	psfile << "0 setgray" << endl;	DecrementOrigin(12);	DrawLabel(XYPt(0), "ReferenceFinder 3.1 by Robert J. Lang", normalLabel);		// Note the point we're searching for.	psfile << "/Times-Roman findfont 9 scalefont setfont" << endl;	DecrementOrigin(12);	stringstream targstr;	targstr << "Target: " << ar;	DrawLabel(XYPt(0), targstr.str(), normalLabel);		// Go through our list and draw all the diagrams in a single row.		for (size_t irow = 0; irow < vr.size(); irow++) {		DecrementOrigin(1.2 * usize * RefBase::paper.pHeight);		vr[irow]->BuildDiagrams();		origin.x = pageSize.bl.x;		for (size_t icol = 0; icol < RefBase::mDgms.size(); icol++) {			RefBase::DrawDiagram(*this, RefBase::mDgms[icol]);			origin.x += 1.2 * RefBase::paper.pWidth * usize;		};				// Also put the text description below the diagrams				origin.x = pageSize.bl.x;		DecrementOrigin(11);		ostringstream sd;		vr[irow]->PutDistanceAndRank(sd, ar);		DrawLabel(XYPt(0), sd.str(), normalLabel);		for (size_t i = 0; i < RefBase::mSequence.size(); i++) {			origin.x = pageSize.bl.x;			ostringstream s;			if (RefBase::mSequence[i]->PutHowto(s)) {				DecrementOrigin(11);				s << ".";				DrawLabel(XYPt(0), s.str(), normalLabel);			}		}	};		// Close the file.		psfile << "showpage" << endl;	psfile << "%%Trailer" << endl;	psfile << "%%Pages: " << pageNum << endl;	psfile.close();}/*******	PSFileDgmr::PutMarkList(const XYPt& pp, vector<RefMark*>& vm) -*	Write the PostScript code that draws folding sequences for a list of marks.******/void PSFileDgmr::PutMarkList(const XYPt& pp, vector<RefMark*>& vm){	PutRefList(pp, vm);}/*******	PSFileDgmr::PutLineList(const XYLine& ll, vector<RefLine*>& vl) -*	Write the PostScript code that draws folding sequences for a list of lines.******/void PSFileDgmr::PutLineList(const XYLine& ll, vector<RefLine*>& vl){	PutRefList(ll, vl);}